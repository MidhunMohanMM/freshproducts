/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, Input, ElementRef, Output, EventEmitter } from '@angular/core';
import * as d3 from 'd3';
/**
 * chart item properties
 * @record
 */
export function PieChartData() { }
function PieChartData_tsickle_Closure_declarations() {
    /**
     * value of item
     * @type {?}
     */
    PieChartData.prototype.value;
    /**
     * caption of item (must be unique)
     * @type {?}
     */
    PieChartData.prototype.caption;
    /**
     * optional color of item (if not set, generated automatically)
     * @type {?|undefined}
     */
    PieChartData.prototype.color;
}
/**
 * internal chart item properties
 * @record
 */
export function InternalPieChartData() { }
function InternalPieChartData_tsickle_Closure_declarations() {
    /**
     * svg path for item
     * @type {?|undefined}
     */
    InternalPieChartData.prototype.path;
    /**
     * delete flag for removing after transition
     * @type {?|undefined}
     */
    InternalPieChartData.prototype.deleted;
}
var PieChartComponent = /** @class */ (function () {
    /**
     * constructor
     * @param element
     */
    function PieChartComponent(element) {
        this.element = element;
        /**
         * chart data, which should be displayed
         */
        this.data = [];
        /**
         * chart width in pixel
         */
        this.width = 250;
        /**
         * chart height in pixel
         */
        this.height = 250;
        /**
         * duration of animation transition
         */
        this.duration = 1000;
        /**
         * inner spacing in pixel, if greater than 0 it defines the radius of the empty circle in the middle
         */
        this.innerSpacing = 0;
        /**
         * outer spacing in pixel
         */
        this.outerSpacing = 1;
        /**
         * fired when user clicks on a chart entry
         */
        this.chartClick = new EventEmitter();
        /**
         * fired when user hovers a chart entry
         */
        this.chartHover = new EventEmitter();
        /**
         * current chart data with angle and path definitions, it will be consistent to the representation
         */
        this.curData = [];
        /**
         * end chart data with angle and path definitions, it will representate the end state and used only for interpolation
         */
        this.endData = [];
        /**
         * copy of last processed data, used to identify changes in ngDoCheck that Angular overlooked
         */
        this.lastData = [];
        /**
         * Function for interrupt a running chart animation. Necessary because if transition is still active
         * when a new transition is started, tween factory function from previos transition will still be fired
         * until end of transition is reached. For entries which have a started transition the tween factory
         * function will be fired multiple times with different tween interpolation range!
         */
        this.interrupt = undefined;
    }
    /**
     * Creates a deep copy of an variable. Do not use this function with recursive objects or
     * browser objects like window or document.
     * ToDo: should be outsourced.
     * @param v
     */
    /**
     * Creates a deep copy of an variable. Do not use this function with recursive objects or
     * browser objects like window or document.
     * ToDo: should be outsourced.
     * @template T
     * @param {?} v
     * @return {?}
     */
    PieChartComponent.prototype.deepCopy = /**
     * Creates a deep copy of an variable. Do not use this function with recursive objects or
     * browser objects like window or document.
     * ToDo: should be outsourced.
     * @template T
     * @param {?} v
     * @return {?}
     */
    function (v) {
        return JSON.parse(JSON.stringify(v));
    };
    ;
    ;
    /**
     * @return {?}
     */
    PieChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.tooltip = /** @type {?} */ (this.element.nativeElement.querySelector('div.pie-chart-tooltip'));
    };
    /**
     * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.
     * Angular only checks references.
     * @param changes
     */
    /**
     * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.
     * Angular only checks references.
     * @param {?} changes
     * @return {?}
     */
    PieChartComponent.prototype.ngOnChanges = /**
     * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.
     * Angular only checks references.
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // check if entries in bound data property has changed
        this.detectDataChange();
    };
    ;
    /**
     * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.
     */
    /**
     * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.
     * @return {?}
     */
    PieChartComponent.prototype.ngDoCheck = /**
     * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.
     * @return {?}
     */
    function () {
        // check if entries in bound data property has changed
        this.detectDataChange();
    };
    ;
    /**
     * Checks whether the data property has changed. This function also check whether only an item property has
     * changed. In case of change the chart will be rendered.
     */
    /**
     * Checks whether the data property has changed. This function also check whether only an item property has
     * changed. In case of change the chart will be rendered.
     * @return {?}
     */
    PieChartComponent.prototype.detectDataChange = /**
     * Checks whether the data property has changed. This function also check whether only an item property has
     * changed. In case of change the chart will be rendered.
     * @return {?}
     */
    function () {
        // fast check: if items were added or removed
        var /** @type {?} */ dataChanged = (this.data.length !== this.lastData.length);
        // detail check:
        if (dataChanged === false) {
            // loop all items
            for (var /** @type {?} */ idx = 0; idx < this.data.length; ++idx) {
                var /** @type {?} */ a = this.data[idx];
                var /** @type {?} */ b = this.lastData[idx];
                // check internal item properties
                dataChanged = dataChanged || (a.caption !== b.caption || a.color !== b.color || a.value !== b.value);
                // for optimization, stop if change detected
                if (dataChanged)
                    break;
            }
        }
        // if change detected
        if (dataChanged) {
            // render chart
            this.render();
            // copy current data to identify changes
            this.lastData = this.deepCopy(this.data);
        }
    };
    ;
    /**
     * Generates a random color for a chart item.
     */
    /**
     * Generates a random color for a chart item.
     * @param {?} value
     * @return {?}
     */
    PieChartComponent.prototype.generateRandomColor = /**
     * Generates a random color for a chart item.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var /** @type {?} */ hue2rgb = function (p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        // make sure, generated color does not exists yet in data array
        var /** @type {?} */ color;
        var /** @type {?} */ uniqueColorGenerated = false;
        while (uniqueColorGenerated === false) {
            var /** @type {?} */ h = (Math.random() + 0.618033988749895) % 1;
            var /** @type {?} */ s = .5;
            var /** @type {?} */ l = .6;
            var /** @type {?} */ q = l + s - l * s;
            var /** @type {?} */ p = 2 * l - q;
            var /** @type {?} */ r = hue2rgb(p, q, h + 1 / 3);
            var /** @type {?} */ g = hue2rgb(p, q, h);
            var /** @type {?} */ b = hue2rgb(p, q, h - 1 / 3);
            color = '#'
                + Math.round(r * 255).toString(16)
                + Math.round(g * 255).toString(16)
                + Math.round(b * 255).toString(16);
            uniqueColorGenerated = (this.data.map(function (d) { return d.color; }).filter(function (d) { return d === color; }).length === 0);
        }
        return color;
    };
    ;
    /**
     * generates a pie chart item definition
     * @param item
     * @param index
     * @param value
     * @param startAngle
     * @param endAngle
     */
    /**
     * generates a pie chart item definition
     * @param {?} item
     * @param {?} index
     * @param {?} value
     * @param {?} startAngle
     * @param {?} endAngle
     * @return {?}
     */
    PieChartComponent.prototype.generatePieArcData = /**
     * generates a pie chart item definition
     * @param {?} item
     * @param {?} index
     * @param {?} value
     * @param {?} startAngle
     * @param {?} endAngle
     * @return {?}
     */
    function (item, index, value, startAngle, endAngle) {
        // generate definition
        var /** @type {?} */ result = {
            data: item,
            index: index,
            value: value,
            startAngle: startAngle,
            endAngle: endAngle,
            padAngle: 0,
            innerRadius: this.radius - 40,
            outerRadius: this.radius
        };
        // generate svg path d-attribute from definition
        (/** @type {?} */ (result.data)).path = this.pathGenerator(result);
        // return definition
        return result;
    };
    ;
    /**
     * Checks whether items were deleted and initiate delete transition for these items.
     */
    /**
     * Checks whether items were deleted and initiate delete transition for these items.
     * @return {?}
     */
    PieChartComponent.prototype.detectDeletedEntries = /**
     * Checks whether items were deleted and initiate delete transition for these items.
     * @return {?}
     */
    function () {
        var _this = this;
        // loop current state entries
        this.curData.forEach(function (curItem, idx) {
            // only check if current entry is not marked as deleted
            if (curItem.data.deleted !== true) {
                // check if entry not exists anymore
                var /** @type {?} */ isDeleted = (_this.data.filter(function (item) { return item.caption === curItem.data.caption; }).length === 0);
                // if entry is deleted
                if (isDeleted) {
                    // mark entry in current state as deleted
                    // mark entry in current state as deleted
                    _this.curData[idx].data.deleted = true;
                    // mark entry in end state as deleted and set value to 0 for transtion
                    // mark entry in end state as deleted and set value to 0 for transtion
                    _this.endData[idx].data.deleted = true;
                    _this.endData[idx].value = 0;
                }
            }
        });
    };
    ;
    /**
     * Checks whether items were inserted and initiate insert transition for these items.
     */
    /**
     * Checks whether items were inserted and initiate insert transition for these items.
     * @return {?}
     */
    PieChartComponent.prototype.detectInsertedEntries = /**
     * Checks whether items were inserted and initiate insert transition for these items.
     * @return {?}
     */
    function () {
        var _this = this;
        // loop given data array
        this.data.forEach(function (item, idx) {
            // check if entry is new
            var /** @type {?} */ isInserted = (_this.curData.filter(function (curItem) { return curItem.data.deleted !== true && curItem.data.caption === item.caption; }).length === 0);
            // if entry is new
            if (isInserted) {
                {
                    var /** @type {?} */ d = _this.generatePieArcData(_this.deepCopy(item), idx, 0, -1, -1);
                    _this.curData.splice(idx, 0, d);
                }
                {
                    var /** @type {?} */ d = _this.generatePieArcData(_this.deepCopy(item), idx, item.value, -1, -1);
                    _this.endData.splice(idx, 0, d);
                }
            }
        });
    };
    ;
    /**
     * Checks whether items were moved and initiate transition for these items.
     */
    /**
     * Checks whether items were moved and initiate transition for these items.
     * @return {?}
     */
    PieChartComponent.prototype.detectMovedEntries = /**
     * Checks whether items were moved and initiate transition for these items.
     * @return {?}
     */
    function () {
        // separate index in current state array
        var /** @type {?} */ curIndex = 0;
        // loop data array
        for (var /** @type {?} */ index = 0; index < this.data.length; ++index) {
            // find next index in current state array, skip items marked as deleted
            while (this.curData[curIndex].data.deleted)
                ++curIndex;
            // check if item is moved by comparing captions
            if (this.data[index].caption !== this.curData[curIndex].data.caption) {
                {
                    // mark item in current state array as deleted
                    this.curData[curIndex].data.deleted = true;
                    // mark item in end state array as deleted and set value to 0 for transition
                    this.endData[curIndex].data.deleted = true;
                    this.endData[curIndex].value = 0;
                }
                {
                    var /** @type {?} */ item = this.deepCopy(this.data[index]);
                    var /** @type {?} */ d = this.generatePieArcData(item, -1, 0, -1, -1);
                    this.curData.splice(curIndex, 0, d);
                }
                {
                    var /** @type {?} */ item = this.deepCopy(this.data[index]);
                    var /** @type {?} */ d = this.generatePieArcData(item, -1, item.value, -1, -1);
                    this.endData.splice(curIndex, 0, d);
                }
                // because of inserting item to the array's, increment index twice
                ++curIndex;
            }
            ++curIndex;
        }
    };
    ;
    /**
     * Synchronize state arrays (curData / endData) with given items (data).
     */
    /**
     * Synchronize state arrays (curData / endData) with given items (data).
     * @return {?}
     */
    PieChartComponent.prototype.syncItems = /**
     * Synchronize state arrays (curData / endData) with given items (data).
     * @return {?}
     */
    function () {
        var _this = this;
        // sync values and colors
        this.data.forEach(function (item, index) {
            // find item index in state array's
            var /** @type {?} */ curIndex = 0;
            for (var /** @type {?} */ i = 0; i < _this.curData.length; ++i) {
                if (!_this.curData[i].data.deleted && _this.curData[i].data.caption === item.caption) {
                    curIndex = i;
                    break;
                }
            }
            // update value in state entries
            // update value in state entries
            _this.curData[curIndex].data.value = item.value;
            _this.endData[curIndex].data.value = item.value;
            // update value in end state entry for transition
            // update value in end state entry for transition
            _this.endData[curIndex].value = item.value;
            // update color in end state entry for transition
            // update color in end state entry for transition
            _this.endData[curIndex].data.color = item.color;
        });
    };
    ;
    /**
     * will be triggerd to animate chart changes.
     * important! this method musst be called within a setTimeout function because of angulars
     * rendering cycle.
     */
    /**
     * will be triggerd to animate chart changes.
     * important! this method musst be called within a setTimeout function because of angulars
     * rendering cycle.
     * @return {?}
     */
    PieChartComponent.prototype.animateChanges = /**
     * will be triggerd to animate chart changes.
     * important! this method musst be called within a setTimeout function because of angulars
     * rendering cycle.
     * @return {?}
     */
    function () {
        var _this = this;
        // get svg element reference
        var /** @type {?} */ svg = (/** @type {?} */ (this.element.nativeElement.querySelector('svg')));
        // reference all path elements in svg element
        var /** @type {?} */ paths = d3.select(svg).selectAll('path');
        // define interruption function to stop running animations
        this.interrupt = function () {
            // call paths interrupt method
            paths.interrupt();
            // delete interupt definition
            delete _this.interrupt;
        };
        // start path animation
        paths
            .transition()
            .duration(this.duration)
            .attrTween('pie-tween-dummy', function (arg0, idx, nodeList) {
            // create interpolation functions to calculate step values
            var /** @type {?} */ iValue = d3.interpolate(_this.curData[idx].value, _this.endData[idx].value);
            var /** @type {?} */ iStartAngle = d3.interpolate(_this.curData[idx].startAngle, _this.endData[idx].startAngle);
            var /** @type {?} */ iEndAngle = d3.interpolate(_this.curData[idx].endAngle, _this.endData[idx].endAngle);
            var /** @type {?} */ iColor = d3.interpolate(_this.curData[idx].data.color, _this.endData[idx].data.color);
            // return factory function for animation steps
            return function (t) {
                // interpolate values by given transition value
                // interpolate values by given transition value
                _this.curData[idx].value = iValue(t);
                _this.curData[idx].startAngle = iStartAngle(t);
                _this.curData[idx].endAngle = iEndAngle(t);
                _this.curData[idx].data.color = iColor(t);
                // generate new path
                // generate new path
                _this.curData[idx].data.path = _this.pathGenerator(_this.curData[idx]);
                // return empty string. This is only necessary for typescript compiler. Nothing should be changed here.
                return '';
            };
        })
            .on('end', function (arg0, idx, nodeList) {
            // when transition is complete for the last item
            if (idx === nodeList.length - 1) {
                // remove as deleted marked entries
                // remove as deleted marked entries
                _this.cleanStateItems();
                // Delete interupt definition, because everything has finished and nothing can be interrupted.
                delete _this.interrupt;
            }
        });
    };
    ;
    /**
     * Must be called after transition ends to remove entries in curData and endData which are marked
     * as deleted.
     */
    /**
     * Must be called after transition ends to remove entries in curData and endData which are marked
     * as deleted.
     * @return {?}
     */
    PieChartComponent.prototype.cleanStateItems = /**
     * Must be called after transition ends to remove entries in curData and endData which are marked
     * as deleted.
     * @return {?}
     */
    function () {
        // clean current state array
        for (var /** @type {?} */ i = this.curData.length - 1; i >= 0; --i) {
            if (this.curData[i].data.deleted === true) {
                this.curData.splice(i, 1);
            }
        }
        // clean end state array
        for (var /** @type {?} */ i = this.endData.length - 1; i >= 0; --i) {
            if (this.endData[i].data.deleted === true) {
                this.endData.splice(i, 1);
            }
        }
    };
    ;
    /**
     * Checks whether all items have assigned color values and if necessary completes colors in given data array.
     */
    /**
     * Checks whether all items have assigned color values and if necessary completes colors in given data array.
     * @return {?}
     */
    PieChartComponent.prototype.initColors = /**
     * Checks whether all items have assigned color values and if necessary completes colors in given data array.
     * @return {?}
     */
    function () {
        var _this = this;
        // loop all entries
        this.data.forEach(function (item) {
            // if no color is assigned
            if (!item.color) {
                // generate random color for item
                item.color = _this.generateRandomColor(item.value);
            }
        });
    };
    ;
    /**
     * Returns maximal angle of current state items.
     */
    /**
     * Returns maximal angle of current state items.
     * @return {?}
     */
    PieChartComponent.prototype.getMaxAngle = /**
     * Returns maximal angle of current state items.
     * @return {?}
     */
    function () {
        var /** @type {?} */ maxAngle = 0;
        this.curData.forEach(function (curItem) {
            if (curItem.endAngle > maxAngle) {
                maxAngle = curItem.endAngle;
            }
        });
        return maxAngle;
    };
    ;
    /**
     * Calculates angles for current and end state items.
     * @param maxAngle last maximal angle in current state to avoid "jumping" transitions
     */
    /**
     * Calculates angles for current and end state items.
     * @param {?} maxAngle last maximal angle in current state to avoid "jumping" transitions
     * @return {?}
     */
    PieChartComponent.prototype.calculateAngles = /**
     * Calculates angles for current and end state items.
     * @param {?} maxAngle last maximal angle in current state to avoid "jumping" transitions
     * @return {?}
     */
    function (maxAngle) {
        var _this = this;
        {
            // calculate sum of values
            var /** @type {?} */ total_1 = this.curData.reduce(function (p, c) { return p + c.value; }, 0);
            // loop items and calculate start and end angles, initialize rendering
            var /** @type {?} */ lastAngle_1 = 0;
            this.curData.forEach(function (item, idx) {
                // calculate angles by last used maximal angle. without data (total=0) simulate 0 values, so draw items in clockwise direction.
                var /** @type {?} */ nextAngle = lastAngle_1 + ((maxAngle) / ((total_1 === 0) ? 1 : total_1)) * item.value;
                item.startAngle = lastAngle_1;
                item.endAngle = nextAngle;
                item.index = idx;
                item.data.path = _this.pathGenerator(item);
                lastAngle_1 = nextAngle;
            });
        }
        {
            // calculate sum of values
            var /** @type {?} */ total_2 = this.endData.reduce(function (p, c) { return p + c.value; }, 0);
            // loop items and calculate start and end angles, initialize rendering
            var /** @type {?} */ lastAngle_2 = 0;
            this.endData.forEach(function (item, idx) {
                // calculate angles with circumference. without data (total=0) simulate 0 values, so draw items in anti-clockwise direction.
                var /** @type {?} */ nextAngle = lastAngle_2 + ((2 * Math.PI) / ((total_2 === 0) ? 1 : total_2)) * item.value;
                item.startAngle = lastAngle_2;
                item.endAngle = nextAngle;
                item.index = idx;
                item.data.path = _this.pathGenerator(item);
                lastAngle_2 = nextAngle;
            });
        }
    };
    ;
    /**
     * fired when mouse enters a pie chart path element and shows tooltip
     * @param {?} event
     * @return {?}
     */
    PieChartComponent.prototype.overPath = /**
     * fired when mouse enters a pie chart path element and shows tooltip
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // get tooltip-text of path element
        var /** @type {?} */ txt = (/** @type {?} */ (event.target)).getAttribute('tooltip');
        // show tooltip and assign text
        d3.select(this.tooltip)
            .html(txt)
            .style('display', 'block')
            .transition()
            .duration(250)
            .style('opacity', 1);
        // get index
        var /** @type {?} */ idx = parseInt((/** @type {?} */ (event.target)).getAttribute('idx'), 10);
        // get caption of element
        var /** @type {?} */ caption = this.curData[idx].data.caption;
        // get original data by caption
        var /** @type {?} */ item = this.data.filter(function (d) { return d.caption === caption; })[0];
        // if data found then emit chart click event
        if (item) {
            this.chartHover.emit(item);
        }
    };
    ;
    /**
     * fired when mouse moves over a pie chart path element and adjusts tooltip
     * @param {?} event
     * @return {?}
     */
    PieChartComponent.prototype.movePath = /**
     * fired when mouse moves over a pie chart path element and adjusts tooltip
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // aggregate scroll positions, because event.page* properties are relative to top left corner of document
        var /** @type {?} */ offsetX = 0;
        var /** @type {?} */ offsetY = 0;
        var /** @type {?} */ element = (/** @type {?} */ (this.tooltip.parentElement));
        while (element) {
            offsetX += element.scrollLeft;
            offsetY += element.scrollTop;
            element = element.parentElement;
        }
        // adjust tooltip
        d3.select(this.tooltip)
            .style('top', (event.pageY - offsetY + 10) + 'px')
            .style('left', (event.pageX - offsetX + 10) + 'px');
    };
    ;
    /**
     * fired when mouse leaves a pie chart path element and hides tooltip
     * @param {?} event
     * @return {?}
     */
    PieChartComponent.prototype.outPath = /**
     * fired when mouse leaves a pie chart path element and hides tooltip
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        // hide tooltip
        d3.select(this.tooltip)
            .transition()
            .duration(250)
            .style('opacity', 0)
            .on('end', function () {
            d3.select(_this.tooltip).style('display', 'none');
        });
    };
    ;
    /**
     * fired when user clicks on a pie chart path element
     * @param {?} event
     * @return {?}
     */
    PieChartComponent.prototype.clickPath = /**
     * fired when user clicks on a pie chart path element
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // get index
        var /** @type {?} */ idx = parseInt((/** @type {?} */ (event.target)).getAttribute('idx'), 10);
        // get caption of element
        var /** @type {?} */ caption = this.curData[idx].data.caption;
        // get original data by caption
        var /** @type {?} */ item = this.data.filter(function (d) { return d.caption === caption; })[0];
        // if data found then emit chart click event
        if (item) {
            this.chartClick.emit(item);
        }
    };
    ;
    /**
     * main rendering function
     */
    /**
     * main rendering function
     * @return {?}
     */
    PieChartComponent.prototype.render = /**
     * main rendering function
     * @return {?}
     */
    function () {
        var _this = this;
        // interrupt possible running animations
        if (this.interrupt)
            this.interrupt();
        // initialize chart colors
        this.initColors();
        // calculate radius
        this.radius = Math.min(this.width, this.height) / 2;
        // calculate middle of chart
        this.center = "translate(" + this.width / 2 + ", " + this.height / 2 + ")";
        // create path generator
        this.pathGenerator = d3.arc().outerRadius(this.radius - this.outerSpacing).innerRadius(this.innerSpacing);
        // get current maximal angle, necessary to avoid "jumping" transitions
        var /** @type {?} */ maxAngle = this.getMaxAngle();
        // check data array for deleted entries and assign transition configuration
        this.detectDeletedEntries();
        // check data array for inserted entries and assign transition configuration
        this.detectInsertedEntries();
        // check data array for moved entries and assign transition configuration
        this.detectMovedEntries();
        // synchronize data entries with current and end state entries
        this.syncItems();
        // calculate angles for current and end state entries
        this.calculateAngles(maxAngle);
        // important! use setTimeout because angular first must exec change detection
        setTimeout(function () {
            // start change animations
            // start change animations
            _this.animateChanges();
        }, 0);
    };
    ;
    PieChartComponent.decorators = [
        { type: Component, args: [{
                    selector: 'oc-pie-chart',
                    template: "<div class=\"pie-chart-tooltip\"></div>\n<svg [attr.width]=\"width\" [attr.height]=\"height\">\n    <g [attr.transform]=\"center\">\n        <path *ngFor=\"let d of curData; let idx = index;\" [attr.idx]=\"idx\" \n            [attr.fill]=\"d.data.color\" [attr.d]=\"d.data.path\" [attr.tooltip]=\"d.data.caption\"\n            (mouseover)=\"overPath($event)\" (mousemove)=\"movePath($event);\" (mouseout)=\"outPath($event)\" (click)=\"clickPath($event)\" />\n    </g>\n</svg>",
                    styles: ["div.pie-chart-tooltip{position:fixed;display:none;opacity:0;font:12px sans-serif;color:#fff;background-color:rgba(35,47,52,.8);padding:5px}path{opacity:.7;stroke:#fff;stroke-width:2px}path:hover{opacity:1;stroke:#e3e3e3}"]
                },] },
    ];
    /** @nocollapse */
    PieChartComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    PieChartComponent.propDecorators = {
        data: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        duration: [{ type: Input }],
        innerSpacing: [{ type: Input }],
        outerSpacing: [{ type: Input }],
        chartClick: [{ type: Output }],
        chartHover: [{ type: Output }]
    };
    return PieChartComponent;
}());
export { PieChartComponent };
function PieChartComponent_tsickle_Closure_declarations() {
    /**
     * chart data, which should be displayed
     * @type {?}
     */
    PieChartComponent.prototype.data;
    /**
     * chart width in pixel
     * @type {?}
     */
    PieChartComponent.prototype.width;
    /**
     * chart height in pixel
     * @type {?}
     */
    PieChartComponent.prototype.height;
    /**
     * duration of animation transition
     * @type {?}
     */
    PieChartComponent.prototype.duration;
    /**
     * inner spacing in pixel, if greater than 0 it defines the radius of the empty circle in the middle
     * @type {?}
     */
    PieChartComponent.prototype.innerSpacing;
    /**
     * outer spacing in pixel
     * @type {?}
     */
    PieChartComponent.prototype.outerSpacing;
    /**
     * fired when user clicks on a chart entry
     * @type {?}
     */
    PieChartComponent.prototype.chartClick;
    /**
     * fired when user hovers a chart entry
     * @type {?}
     */
    PieChartComponent.prototype.chartHover;
    /**
     * pie chart radius in pixel
     * @type {?}
     */
    PieChartComponent.prototype.radius;
    /**
     * transform-attribute to center chart vertical and horizontal
     * @type {?}
     */
    PieChartComponent.prototype.center;
    /**
     * current chart data with angle and path definitions, it will be consistent to the representation
     * @type {?}
     */
    PieChartComponent.prototype.curData;
    /**
     * end chart data with angle and path definitions, it will representate the end state and used only for interpolation
     * @type {?}
     */
    PieChartComponent.prototype.endData;
    /**
     * path generator function (internal use only)
     * @type {?}
     */
    PieChartComponent.prototype.pathGenerator;
    /**
     * copy of last processed data, used to identify changes in ngDoCheck that Angular overlooked
     * @type {?}
     */
    PieChartComponent.prototype.lastData;
    /**
     * Function for interrupt a running chart animation. Necessary because if transition is still active
     * when a new transition is started, tween factory function from previos transition will still be fired
     * until end of transition is reached. For entries which have a started transition the tween factory
     * function will be fired multiple times with different tween interpolation range!
     * @type {?}
     */
    PieChartComponent.prototype.interrupt;
    /**
     * reference to tooltip div element
     * @type {?}
     */
    PieChartComponent.prototype.tooltip;
    /** @type {?} */
    PieChartComponent.prototype.element;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGllLWNoYXJ0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BvcGl0emNvbnN1bHRpbmcvcGllLWNoYXJ0LyIsInNvdXJjZXMiOlsibGliL3BpZS1jaGFydC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFzQixVQUFVLEVBQXlCLE1BQU0sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFOUgsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNEV2Qjs7O09BR0c7SUFDSCwyQkFDVTtRQUFBLFlBQU8sR0FBUCxPQUFPOzs7O29CQTVDb0IsRUFBRTs7OztxQkFFdEIsR0FBRzs7OztzQkFFRixHQUFHOzs7O3dCQUVELElBQUk7Ozs7NEJBRUEsQ0FBQzs7Ozs0QkFFRCxDQUFDOzs7OzBCQUUwQixJQUFJLFlBQVksRUFBRTs7OzswQkFFbEIsSUFBSSxZQUFZLEVBQUU7Ozs7dUJBT3RDLEVBQUU7Ozs7dUJBRUQsRUFBRTs7Ozt3QkFJTSxFQUFFOzs7Ozs7O3lCQW9QVixTQUFTO0tBbE9yQztJQWhCSjs7Ozs7T0FLRzs7Ozs7Ozs7O0lBQ08sb0NBQVE7Ozs7Ozs7O0lBQWxCLFVBQXNCLENBQUk7UUFDeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3RDO0lBQUEsQ0FBQztJQVFFLENBQUM7Ozs7SUFFTCxvQ0FBUTs7O0lBQVI7UUFDRSxJQUFJLENBQUMsT0FBTyxxQkFBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQW1CLENBQUEsQ0FBQztLQUNwRztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSCx1Q0FBVzs7Ozs7O0lBQVgsVUFBWSxPQUFzQjs7UUFF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QUFJLENBQUMsTUFBTSxHQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDOztRQUV4RyxxQkFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDOztRQUVwQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQzs7UUFFNUIsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O1FBRTdCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDOztRQUUxQixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7O1FBRWpCLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7O1FBRS9CLFVBQVUsQ0FBRTs7WUFFVixBQURBLDBCQUEwQjtZQUMxQixLQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDdkIsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNQO0lBQUEsQ0FBQzs7Z0JBM2hCSCxTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFFBQVEsRUFBRSw2ZEFPTDtvQkFDTCxNQUFNLEVBQUUsQ0FBQyw4TkFBOE4sQ0FBQztpQkFDek87Ozs7Z0JBcEM4QyxVQUFVOzs7dUJBdUN0RCxLQUFLO3dCQUVMLEtBQUs7eUJBRUwsS0FBSzsyQkFFTCxLQUFLOytCQUVMLEtBQUs7K0JBRUwsS0FBSzs2QkFFTCxNQUFNOzZCQUVOLE1BQU07OzRCQXJEVDs7U0FxQ2EsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBEb0NoZWNrLCBFbGVtZW50UmVmLCBTaW1wbGVDaGFuZ2VzLCBPbkluaXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XHJcblxyXG4vKiogY2hhcnQgaXRlbSBwcm9wZXJ0aWVzICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGllQ2hhcnREYXRhIHtcclxuICAvKiogdmFsdWUgb2YgaXRlbSAqL1xyXG4gIHZhbHVlOiBudW1iZXI7XHJcbiAgLyoqIGNhcHRpb24gb2YgaXRlbSAobXVzdCBiZSB1bmlxdWUpICovXHJcbiAgY2FwdGlvbjogc3RyaW5nO1xyXG4gIC8qKiBvcHRpb25hbCBjb2xvciBvZiBpdGVtIChpZiBub3Qgc2V0LCBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSkgKi9cclxuICBjb2xvcj86IHN0cmluZztcclxufVxyXG5cclxuLyoqIGludGVybmFsIGNoYXJ0IGl0ZW0gcHJvcGVydGllcyAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsUGllQ2hhcnREYXRhIGV4dGVuZHMgUGllQ2hhcnREYXRhIHtcclxuICAvKiogc3ZnIHBhdGggZm9yIGl0ZW0gKi9cclxuICBwYXRoPzogc3RyaW5nO1xyXG4gIC8qKiBkZWxldGUgZmxhZyBmb3IgcmVtb3ZpbmcgYWZ0ZXIgdHJhbnNpdGlvbiAqL1xyXG4gIGRlbGV0ZWQ/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKiogaW50ZXJuYWwgdHlwZSBmb3Igb3B0aW1pemF0aW9uICovXHJcbmV4cG9ydCB0eXBlIFBpZUFyY0RhdGEgPSBkMy5QaWVBcmNEYXR1bTxJbnRlcm5hbFBpZUNoYXJ0RGF0YT4gJiBkMy5EZWZhdWx0QXJjT2JqZWN0O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdvYy1waWUtY2hhcnQnLFxyXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBpZS1jaGFydC10b29sdGlwXCI+PC9kaXY+XHJcbjxzdmcgW2F0dHIud2lkdGhdPVwid2lkdGhcIiBbYXR0ci5oZWlnaHRdPVwiaGVpZ2h0XCI+XHJcbiAgICA8ZyBbYXR0ci50cmFuc2Zvcm1dPVwiY2VudGVyXCI+XHJcbiAgICAgICAgPHBhdGggKm5nRm9yPVwibGV0IGQgb2YgY3VyRGF0YTsgbGV0IGlkeCA9IGluZGV4O1wiIFthdHRyLmlkeF09XCJpZHhcIiBcclxuICAgICAgICAgICAgW2F0dHIuZmlsbF09XCJkLmRhdGEuY29sb3JcIiBbYXR0ci5kXT1cImQuZGF0YS5wYXRoXCIgW2F0dHIudG9vbHRpcF09XCJkLmRhdGEuY2FwdGlvblwiXHJcbiAgICAgICAgICAgIChtb3VzZW92ZXIpPVwib3ZlclBhdGgoJGV2ZW50KVwiIChtb3VzZW1vdmUpPVwibW92ZVBhdGgoJGV2ZW50KTtcIiAobW91c2VvdXQpPVwib3V0UGF0aCgkZXZlbnQpXCIgKGNsaWNrKT1cImNsaWNrUGF0aCgkZXZlbnQpXCIgLz5cclxuICAgIDwvZz5cclxuPC9zdmc+YCxcclxuICBzdHlsZXM6IFtgZGl2LnBpZS1jaGFydC10b29sdGlwe3Bvc2l0aW9uOmZpeGVkO2Rpc3BsYXk6bm9uZTtvcGFjaXR5OjA7Zm9udDoxMnB4IHNhbnMtc2VyaWY7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMzUsNDcsNTIsLjgpO3BhZGRpbmc6NXB4fXBhdGh7b3BhY2l0eTouNztzdHJva2U6I2ZmZjtzdHJva2Utd2lkdGg6MnB4fXBhdGg6aG92ZXJ7b3BhY2l0eToxO3N0cm9rZTojZTNlM2UzfWBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQaWVDaGFydENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrIHtcclxuICAvKiogY2hhcnQgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGRpc3BsYXllZCAqL1xyXG4gIEBJbnB1dCgpIGRhdGE6IEFycmF5PFBpZUNoYXJ0RGF0YT4gPSBbXTtcclxuICAvKiogY2hhcnQgd2lkdGggaW4gcGl4ZWwgKi9cclxuICBASW5wdXQoKSB3aWR0aCA9IDI1MDtcclxuICAvKiogY2hhcnQgaGVpZ2h0IGluIHBpeGVsICovXHJcbiAgQElucHV0KCkgaGVpZ2h0ID0gMjUwO1xyXG4gIC8qKiBkdXJhdGlvbiBvZiBhbmltYXRpb24gdHJhbnNpdGlvbiAqL1xyXG4gIEBJbnB1dCgpIGR1cmF0aW9uID0gMTAwMDtcclxuICAvKiogaW5uZXIgc3BhY2luZyBpbiBwaXhlbCwgaWYgZ3JlYXRlciB0aGFuIDAgaXQgZGVmaW5lcyB0aGUgcmFkaXVzIG9mIHRoZSBlbXB0eSBjaXJjbGUgaW4gdGhlIG1pZGRsZSAqL1xyXG4gIEBJbnB1dCgpIGlubmVyU3BhY2luZyA9IDA7XHJcbiAgLyoqIG91dGVyIHNwYWNpbmcgaW4gcGl4ZWwgKi9cclxuICBASW5wdXQoKSBvdXRlclNwYWNpbmcgPSAxO1xyXG4gIC8qKiBmaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGEgY2hhcnQgZW50cnkgKi9cclxuICBAT3V0cHV0KCkgY2hhcnRDbGljazogRXZlbnRFbWl0dGVyPFBpZUNoYXJ0RGF0YT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgLyoqIGZpcmVkIHdoZW4gdXNlciBob3ZlcnMgYSBjaGFydCBlbnRyeSAqL1xyXG4gIEBPdXRwdXQoKSBjaGFydEhvdmVyOiBFdmVudEVtaXR0ZXI8UGllQ2hhcnREYXRhPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgLyoqIHBpZSBjaGFydCByYWRpdXMgaW4gcGl4ZWwgKi9cclxuICBwdWJsaWMgcmFkaXVzOiBudW1iZXI7XHJcbiAgLyoqIHRyYW5zZm9ybS1hdHRyaWJ1dGUgdG8gY2VudGVyIGNoYXJ0IHZlcnRpY2FsIGFuZCBob3Jpem9udGFsICovXHJcbiAgcHVibGljIGNlbnRlcjogc3RyaW5nO1xyXG4gIC8qKiBjdXJyZW50IGNoYXJ0IGRhdGEgd2l0aCBhbmdsZSBhbmQgcGF0aCBkZWZpbml0aW9ucywgaXQgd2lsbCBiZSBjb25zaXN0ZW50IHRvIHRoZSByZXByZXNlbnRhdGlvbiAqL1xyXG4gIHB1YmxpYyBjdXJEYXRhOiBQaWVBcmNEYXRhW10gPSBbXTtcclxuICAvKiogZW5kIGNoYXJ0IGRhdGEgd2l0aCBhbmdsZSBhbmQgcGF0aCBkZWZpbml0aW9ucywgaXQgd2lsbCByZXByZXNlbnRhdGUgdGhlIGVuZCBzdGF0ZSBhbmQgdXNlZCBvbmx5IGZvciBpbnRlcnBvbGF0aW9uICovXHJcbiAgcHJpdmF0ZSBlbmREYXRhOiBQaWVBcmNEYXRhW10gPSBbXTtcclxuICAvKiogcGF0aCBnZW5lcmF0b3IgZnVuY3Rpb24gKGludGVybmFsIHVzZSBvbmx5KSAqL1xyXG4gIHByb3RlY3RlZCBwYXRoR2VuZXJhdG9yOiBkMy5BcmM8YW55LCBkMy5EZWZhdWx0QXJjT2JqZWN0PjtcclxuICAvKiogY29weSBvZiBsYXN0IHByb2Nlc3NlZCBkYXRhLCB1c2VkIHRvIGlkZW50aWZ5IGNoYW5nZXMgaW4gbmdEb0NoZWNrIHRoYXQgQW5ndWxhciBvdmVybG9va2VkICovXHJcbiAgcHJpdmF0ZSBsYXN0RGF0YTogQXJyYXk8UGllQ2hhcnREYXRhPiA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIGFuIHZhcmlhYmxlLiBEbyBub3QgdXNlIHRoaXMgZnVuY3Rpb24gd2l0aCByZWN1cnNpdmUgb2JqZWN0cyBvclxyXG4gICAqIGJyb3dzZXIgb2JqZWN0cyBsaWtlIHdpbmRvdyBvciBkb2N1bWVudC5cclxuICAgKiBUb0RvOiBzaG91bGQgYmUgb3V0c291cmNlZC5cclxuICAgKiBAcGFyYW0gdiBcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZGVlcENvcHk8VD4odjogVCk6IFQge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodikpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWZcclxuICApIHt9O1xyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHRoaXMudG9vbHRpcCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5waWUtY2hhcnQtdG9vbHRpcCcpIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZWQgd2hlbiBBbmd1bGFyIChyZS0pc2V0cyBkYXRhLWJvdW5kIHByb3BlcnRpZXMuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgZmlyZSB3aGVuIGNoYW5nZWQgZGF0YSBpbiBib3VuZCBvYmplY3RzIG9yIGFycmF5cy5cclxuICAgKiBBbmd1bGFyIG9ubHkgY2hlY2tzIHJlZmVyZW5jZXMuXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgXHJcbiAgICovXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgLy8gY2hlY2sgaWYgZW50cmllcyBpbiBib3VuZCBkYXRhIHByb3BlcnR5IGhhcyBjaGFuZ2VkXHJcbiAgICB0aGlzLmRldGVjdERhdGFDaGFuZ2UoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGaXJlZCBkdXJpbmcgZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBydW4gdG8gZGV0ZWN0IGFuZCBhY3QgdXBvbiBjaGFuZ2VzIHRoYXQgQW5ndWxhciBjYW4ndCBvciB3b24ndCBkZXRlY3Qgb24gaXRzIG93bi5cclxuICAgKi9cclxuICBuZ0RvQ2hlY2soKSB7XHJcbiAgICAvLyBjaGVjayBpZiBlbnRyaWVzIGluIGJvdW5kIGRhdGEgcHJvcGVydHkgaGFzIGNoYW5nZWRcclxuICAgIHRoaXMuZGV0ZWN0RGF0YUNoYW5nZSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkYXRhIHByb3BlcnR5IGhhcyBjaGFuZ2VkLiBUaGlzIGZ1bmN0aW9uIGFsc28gY2hlY2sgd2hldGhlciBvbmx5IGFuIGl0ZW0gcHJvcGVydHkgaGFzXHJcbiAgICogY2hhbmdlZC4gSW4gY2FzZSBvZiBjaGFuZ2UgdGhlIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGRldGVjdERhdGFDaGFuZ2UoKSB7XHJcbiAgICAvLyBmYXN0IGNoZWNrOiBpZiBpdGVtcyB3ZXJlIGFkZGVkIG9yIHJlbW92ZWRcclxuICAgIGxldCBkYXRhQ2hhbmdlZCA9ICh0aGlzLmRhdGEubGVuZ3RoICE9PSB0aGlzLmxhc3REYXRhLmxlbmd0aCk7XHJcbiAgICAvLyBkZXRhaWwgY2hlY2s6XHJcbiAgICBpZihkYXRhQ2hhbmdlZCA9PT0gZmFsc2Upe1xyXG4gICAgICAvLyBsb29wIGFsbCBpdGVtc1xyXG4gICAgICBmb3IobGV0IGlkeD0wOyBpZHg8dGhpcy5kYXRhLmxlbmd0aDsgKytpZHgpe1xyXG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmRhdGFbaWR4XTtcclxuICAgICAgICBjb25zdCBiID0gdGhpcy5sYXN0RGF0YVtpZHhdO1xyXG4gICAgICAgIC8vIGNoZWNrIGludGVybmFsIGl0ZW0gcHJvcGVydGllc1xyXG4gICAgICAgIGRhdGFDaGFuZ2VkID0gZGF0YUNoYW5nZWQgfHwgKGEuY2FwdGlvbiAhPT0gYi5jYXB0aW9uIHx8IGEuY29sb3IgIT09IGIuY29sb3IgfHwgYS52YWx1ZSAhPT0gYi52YWx1ZSk7XHJcbiAgICAgICAgLy8gZm9yIG9wdGltaXphdGlvbiwgc3RvcCBpZiBjaGFuZ2UgZGV0ZWN0ZWRcclxuICAgICAgICBpZihkYXRhQ2hhbmdlZCkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGlmIGNoYW5nZSBkZXRlY3RlZFxyXG4gICAgaWYoZGF0YUNoYW5nZWQpe1xyXG4gICAgICAvLyByZW5kZXIgY2hhcnRcclxuICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgLy8gY29weSBjdXJyZW50IGRhdGEgdG8gaWRlbnRpZnkgY2hhbmdlc1xyXG4gICAgICB0aGlzLmxhc3REYXRhID0gdGhpcy5kZWVwQ29weSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBjb2xvciBmb3IgYSBjaGFydCBpdGVtLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZW5lcmF0ZVJhbmRvbUNvbG9yKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgaHVlMnJnYiA9IChwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmKHQgPCAwKSB0ICs9IDE7IFxyXG4gICAgICBpZih0ID4gMSkgdCAtPSAxOyBcclxuICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xyXG4gICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xyXG4gICAgICByZXR1cm4gcDtcclxuICAgIH07XHJcbiAgICAvLyBtYWtlIHN1cmUsIGdlbmVyYXRlZCBjb2xvciBkb2VzIG5vdCBleGlzdHMgeWV0IGluIGRhdGEgYXJyYXlcclxuICAgIGxldCBjb2xvcjtcclxuICAgIGxldCB1bmlxdWVDb2xvckdlbmVyYXRlZCA9IGZhbHNlO1xyXG4gICAgd2hpbGUodW5pcXVlQ29sb3JHZW5lcmF0ZWQgPT09IGZhbHNlKXtcclxuICAgICAgY29uc3QgaCA9IChNYXRoLnJhbmRvbSgpICsgMC42MTgwMzM5ODg3NDk4OTUpICUgMTtcclxuICAgICAgY29uc3QgcyA9IC41O1xyXG4gICAgICBjb25zdCBsID0gLjY7XHJcbiAgICAgIGxldCBxID0gbCArIHMgLSBsICogcztcclxuICAgICAgbGV0IHAgPSAyICogbCAtIHE7XHJcbiAgICAgIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xyXG4gICAgICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcclxuICAgICAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XHJcbiAgICAgIGNvbG9yID0gJyMnIFxyXG4gICAgICAgICsgTWF0aC5yb3VuZChyICogMjU1KS50b1N0cmluZygxNilcclxuICAgICAgICArIE1hdGgucm91bmQoZyAqIDI1NSkudG9TdHJpbmcoMTYpXHJcbiAgICAgICAgKyBNYXRoLnJvdW5kKGIgKiAyNTUpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgdW5pcXVlQ29sb3JHZW5lcmF0ZWQgPSAodGhpcy5kYXRhLm1hcCggKGQpID0+IGQuY29sb3IpLmZpbHRlciggKGQpID0+IGQgPT09IGNvbG9yKS5sZW5ndGggPT09IDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGdlbmVyYXRlcyBhIHBpZSBjaGFydCBpdGVtIGRlZmluaXRpb25cclxuICAgKiBAcGFyYW0gaXRlbSBcclxuICAgKiBAcGFyYW0gaW5kZXggXHJcbiAgICogQHBhcmFtIHZhbHVlIFxyXG4gICAqIEBwYXJhbSBzdGFydEFuZ2xlIFxyXG4gICAqIEBwYXJhbSBlbmRBbmdsZSBcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2VuZXJhdGVQaWVBcmNEYXRhKGl0ZW06IFBpZUNoYXJ0RGF0YSwgaW5kZXg6IG51bWJlciwgdmFsdWU6IG51bWJlciwgc3RhcnRBbmdsZTogbnVtYmVyLCBlbmRBbmdsZTogbnVtYmVyKTogUGllQXJjRGF0YSB7XHJcbiAgICAvLyBnZW5lcmF0ZSBkZWZpbml0aW9uXHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgIGRhdGE6IGl0ZW0sXHJcbiAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXHJcbiAgICAgIHBhZEFuZ2xlOiAwLFxyXG4gICAgICBpbm5lclJhZGl1czogdGhpcy5yYWRpdXMgLSA0MCxcclxuICAgICAgb3V0ZXJSYWRpdXM6IHRoaXMucmFkaXVzXHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGUgc3ZnIHBhdGggZC1hdHRyaWJ1dGUgZnJvbSBkZWZpbml0aW9uXHJcbiAgICAocmVzdWx0LmRhdGEgYXMgSW50ZXJuYWxQaWVDaGFydERhdGEpLnBhdGggPSB0aGlzLnBhdGhHZW5lcmF0b3IocmVzdWx0KTtcclxuICAgIC8vIHJldHVybiBkZWZpbml0aW9uXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIGl0ZW1zIHdlcmUgZGVsZXRlZCBhbmQgaW5pdGlhdGUgZGVsZXRlIHRyYW5zaXRpb24gZm9yIHRoZXNlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkZXRlY3REZWxldGVkRW50cmllcygpIHtcclxuICAgIC8vIGxvb3AgY3VycmVudCBzdGF0ZSBlbnRyaWVzXHJcbiAgICB0aGlzLmN1ckRhdGEuZm9yRWFjaCggKGN1ckl0ZW0sIGlkeCkgPT4ge1xyXG4gICAgICAvLyBvbmx5IGNoZWNrIGlmIGN1cnJlbnQgZW50cnkgaXMgbm90IG1hcmtlZCBhcyBkZWxldGVkXHJcbiAgICAgIGlmKGN1ckl0ZW0uZGF0YS5kZWxldGVkIT09dHJ1ZSl7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgZW50cnkgbm90IGV4aXN0cyBhbnltb3JlXHJcbiAgICAgICAgY29uc3QgaXNEZWxldGVkID0gKHRoaXMuZGF0YS5maWx0ZXIoIChpdGVtKSA9PiBpdGVtLmNhcHRpb24gPT09IGN1ckl0ZW0uZGF0YS5jYXB0aW9uKS5sZW5ndGggPT09IDApO1xyXG4gICAgICAgIC8vIGlmIGVudHJ5IGlzIGRlbGV0ZWRcclxuICAgICAgICBpZihpc0RlbGV0ZWQpe1xyXG4gICAgICAgICAgLy8gbWFyayBlbnRyeSBpbiBjdXJyZW50IHN0YXRlIGFzIGRlbGV0ZWRcclxuICAgICAgICAgIHRoaXMuY3VyRGF0YVtpZHhdLmRhdGEuZGVsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAvLyBtYXJrIGVudHJ5IGluIGVuZCBzdGF0ZSBhcyBkZWxldGVkIGFuZCBzZXQgdmFsdWUgdG8gMCBmb3IgdHJhbnN0aW9uXHJcbiAgICAgICAgICB0aGlzLmVuZERhdGFbaWR4XS5kYXRhLmRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5lbmREYXRhW2lkeF0udmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgaXRlbXMgd2VyZSBpbnNlcnRlZCBhbmQgaW5pdGlhdGUgaW5zZXJ0IHRyYW5zaXRpb24gZm9yIHRoZXNlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkZXRlY3RJbnNlcnRlZEVudHJpZXMoKTogdm9pZCB7XHJcbiAgICAvLyBsb29wIGdpdmVuIGRhdGEgYXJyYXlcclxuICAgIHRoaXMuZGF0YS5mb3JFYWNoKCAoaXRlbSwgaWR4KSA9PiB7XHJcbiAgICAgIC8vIGNoZWNrIGlmIGVudHJ5IGlzIG5ld1xyXG4gICAgICBjb25zdCBpc0luc2VydGVkID0gKHRoaXMuY3VyRGF0YS5maWx0ZXIoIChjdXJJdGVtKSA9PiBjdXJJdGVtLmRhdGEuZGVsZXRlZCE9PXRydWUgJiYgY3VySXRlbS5kYXRhLmNhcHRpb24gPT09IGl0ZW0uY2FwdGlvbikubGVuZ3RoPT09MCk7XHJcbiAgICAgIC8vIGlmIGVudHJ5IGlzIG5ld1xyXG4gICAgICBpZihpc0luc2VydGVkKXtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBjdXJyZW50IHN0YXRlIGVudHJ5IHdpdGggdmFsdWUgb2YgMCBmb3IgdHJhbnNpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbmVyYXRlUGllQXJjRGF0YSh0aGlzLmRlZXBDb3B5KGl0ZW0pLCBpZHgsIDAsIC0xLCAtMSk7XHJcbiAgICAgICAgICB0aGlzLmN1ckRhdGEuc3BsaWNlKGlkeCwgMCwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGdlbmVyYXRlIGVuZCBzdGF0ZSBlbnRyeSB3aXRoIGdpdmVuIHZhbHVlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuZXJhdGVQaWVBcmNEYXRhKHRoaXMuZGVlcENvcHkoaXRlbSksIGlkeCwgaXRlbS52YWx1ZSwgLTEsIC0xKTtcclxuICAgICAgICAgIHRoaXMuZW5kRGF0YS5zcGxpY2UoaWR4LCAwLCBkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIGl0ZW1zIHdlcmUgbW92ZWQgYW5kIGluaXRpYXRlIHRyYW5zaXRpb24gZm9yIHRoZXNlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkZXRlY3RNb3ZlZEVudHJpZXMoKTogdm9pZCB7XHJcbiAgICAvLyBzZXBhcmF0ZSBpbmRleCBpbiBjdXJyZW50IHN0YXRlIGFycmF5XHJcbiAgICBsZXQgY3VySW5kZXggPSAwO1xyXG4gICAgLy8gbG9vcCBkYXRhIGFycmF5XHJcbiAgICBmb3IobGV0IGluZGV4PTA7IGluZGV4PHRoaXMuZGF0YS5sZW5ndGg7ICsraW5kZXgpe1xyXG4gICAgICAvLyBmaW5kIG5leHQgaW5kZXggaW4gY3VycmVudCBzdGF0ZSBhcnJheSwgc2tpcCBpdGVtcyBtYXJrZWQgYXMgZGVsZXRlZFxyXG4gICAgICB3aGlsZSh0aGlzLmN1ckRhdGFbY3VySW5kZXhdLmRhdGEuZGVsZXRlZCkgKytjdXJJbmRleDsgXHJcbiAgICAgIC8vIGNoZWNrIGlmIGl0ZW0gaXMgbW92ZWQgYnkgY29tcGFyaW5nIGNhcHRpb25zXHJcbiAgICAgIGlmKHRoaXMuZGF0YVtpbmRleF0uY2FwdGlvbiAhPT0gdGhpcy5jdXJEYXRhW2N1ckluZGV4XS5kYXRhLmNhcHRpb24pe1xyXG4gICAgICAgIC8vIHVwZGF0aW5nIHN0YXRlIGl0ZW1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gbWFyayBpdGVtIGluIGN1cnJlbnQgc3RhdGUgYXJyYXkgYXMgZGVsZXRlZFxyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhW2N1ckluZGV4XS5kYXRhLmRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gbWFyayBpdGVtIGluIGVuZCBzdGF0ZSBhcnJheSBhcyBkZWxldGVkIGFuZCBzZXQgdmFsdWUgdG8gMCBmb3IgdHJhbnNpdGlvblxyXG4gICAgICAgICAgdGhpcy5lbmREYXRhW2N1ckluZGV4XS5kYXRhLmRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5lbmREYXRhW2N1ckluZGV4XS52YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluc2VydCBlbnRyeSBpbiBjdXJyZW50IHN0YXRlIGFycmF5IHdpdGggdmFsdWUgMCBmb3IgdHJhbnNpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmRlZXBDb3B5KHRoaXMuZGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuZXJhdGVQaWVBcmNEYXRhKGl0ZW0sIC0xLCAwLCAtMSwgLTEpO1xyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhLnNwbGljZShjdXJJbmRleCwgMCwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluc2VydCBlbnRyeSBpbiBlbmQgc3RhdGUgYXJyYXkgd2l0aCBnaXZlbiB2YWx1ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmRlZXBDb3B5KHRoaXMuZGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuZXJhdGVQaWVBcmNEYXRhKGl0ZW0sIC0xLCBpdGVtLnZhbHVlLCAtMSwgLTEpO1xyXG4gICAgICAgICAgdGhpcy5lbmREYXRhLnNwbGljZShjdXJJbmRleCwgMCwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgaW5zZXJ0aW5nIGl0ZW0gdG8gdGhlIGFycmF5J3MsIGluY3JlbWVudCBpbmRleCB0d2ljZVxyXG4gICAgICAgICsrY3VySW5kZXg7XHJcbiAgICAgIH1cclxuICAgICAgKytjdXJJbmRleDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTeW5jaHJvbml6ZSBzdGF0ZSBhcnJheXMgKGN1ckRhdGEgLyBlbmREYXRhKSB3aXRoIGdpdmVuIGl0ZW1zIChkYXRhKS5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc3luY0l0ZW1zKCk6IHZvaWQge1xyXG4gICAgLy8gc3luYyB2YWx1ZXMgYW5kIGNvbG9yc1xyXG4gICAgdGhpcy5kYXRhLmZvckVhY2goIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAvLyBmaW5kIGl0ZW0gaW5kZXggaW4gc3RhdGUgYXJyYXknc1xyXG4gICAgICBsZXQgY3VySW5kZXggPSAwO1xyXG4gICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLmN1ckRhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGlmKCF0aGlzLmN1ckRhdGFbaV0uZGF0YS5kZWxldGVkICYmIHRoaXMuY3VyRGF0YVtpXS5kYXRhLmNhcHRpb24gPT09IGl0ZW0uY2FwdGlvbil7XHJcbiAgICAgICAgICBjdXJJbmRleCA9IGk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gdXBkYXRlIHZhbHVlIGluIHN0YXRlIGVudHJpZXNcclxuICAgICAgdGhpcy5jdXJEYXRhW2N1ckluZGV4XS5kYXRhLnZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgdGhpcy5lbmREYXRhW2N1ckluZGV4XS5kYXRhLnZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgLy8gdXBkYXRlIHZhbHVlIGluIGVuZCBzdGF0ZSBlbnRyeSBmb3IgdHJhbnNpdGlvblxyXG4gICAgICB0aGlzLmVuZERhdGFbY3VySW5kZXhdLnZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgLy8gdXBkYXRlIGNvbG9yIGluIGVuZCBzdGF0ZSBlbnRyeSBmb3IgdHJhbnNpdGlvblxyXG4gICAgICB0aGlzLmVuZERhdGFbY3VySW5kZXhdLmRhdGEuY29sb3IgPSBpdGVtLmNvbG9yO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gZm9yIGludGVycnVwdCBhIHJ1bm5pbmcgY2hhcnQgYW5pbWF0aW9uLiBOZWNlc3NhcnkgYmVjYXVzZSBpZiB0cmFuc2l0aW9uIGlzIHN0aWxsIGFjdGl2ZVxyXG4gICAqIHdoZW4gYSBuZXcgdHJhbnNpdGlvbiBpcyBzdGFydGVkLCB0d2VlbiBmYWN0b3J5IGZ1bmN0aW9uIGZyb20gcHJldmlvcyB0cmFuc2l0aW9uIHdpbGwgc3RpbGwgYmUgZmlyZWQgXHJcbiAgICogdW50aWwgZW5kIG9mIHRyYW5zaXRpb24gaXMgcmVhY2hlZC4gRm9yIGVudHJpZXMgd2hpY2ggaGF2ZSBhIHN0YXJ0ZWQgdHJhbnNpdGlvbiB0aGUgdHdlZW4gZmFjdG9yeVxyXG4gICAqIGZ1bmN0aW9uIHdpbGwgYmUgZmlyZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgdHdlZW4gaW50ZXJwb2xhdGlvbiByYW5nZSFcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgaW50ZXJydXB0OiBGdW5jdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgLyoqXHJcbiAgICogd2lsbCBiZSB0cmlnZ2VyZCB0byBhbmltYXRlIGNoYXJ0IGNoYW5nZXMuXHJcbiAgICogaW1wb3J0YW50ISB0aGlzIG1ldGhvZCBtdXNzdCBiZSBjYWxsZWQgd2l0aGluIGEgc2V0VGltZW91dCBmdW5jdGlvbiBiZWNhdXNlIG9mIGFuZ3VsYXJzIFxyXG4gICAqIHJlbmRlcmluZyBjeWNsZS5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYW5pbWF0ZUNoYW5nZXMoKTogdm9pZCB7XHJcbiAgICAvLyBnZXQgc3ZnIGVsZW1lbnQgcmVmZXJlbmNlXHJcbiAgICBjb25zdCBzdmcgPSAodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJykgYXMgU1ZHRWxlbWVudCk7XHJcbiAgICAvLyByZWZlcmVuY2UgYWxsIHBhdGggZWxlbWVudHMgaW4gc3ZnIGVsZW1lbnRcclxuICAgIGNvbnN0IHBhdGhzID0gZDMuc2VsZWN0KHN2Zykuc2VsZWN0QWxsKCdwYXRoJyk7XHJcbiAgICAvLyBkZWZpbmUgaW50ZXJydXB0aW9uIGZ1bmN0aW9uIHRvIHN0b3AgcnVubmluZyBhbmltYXRpb25zXHJcbiAgICB0aGlzLmludGVycnVwdCA9ICgpID0+IHtcclxuICAgICAgLy8gY2FsbCBwYXRocyBpbnRlcnJ1cHQgbWV0aG9kXHJcbiAgICAgIHBhdGhzLmludGVycnVwdCgpO1xyXG4gICAgICAvLyBkZWxldGUgaW50ZXJ1cHQgZGVmaW5pdGlvblxyXG4gICAgICBkZWxldGUgdGhpcy5pbnRlcnJ1cHQ7XHJcbiAgICB9O1xyXG4gICAgLy8gc3RhcnQgcGF0aCBhbmltYXRpb25cclxuICAgIHBhdGhzXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKHRoaXMuZHVyYXRpb24pXHJcbiAgICAgIC8vIFVzZSBkMyBhdHRyVHdlZW4gdHJhbnNpdGlvbiBtZXRob2Qgd2l0aCBkdW1teSBhdHRyaWJ1dGUuIE1ha2Ugc3VyZSB0aGUgZHVtbXkgYXR0cmlidXRlIGRvZXMgbm90XHJcbiAgICAgIC8vIGV4aXN0cyBhdCBwYXRoIGVsZW1lbnRzIVxyXG4gICAgICAuYXR0clR3ZWVuKCdwaWUtdHdlZW4tZHVtbXknLCAoYXJnMCwgaWR4LCBub2RlTGlzdCkgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9ucyB0byBjYWxjdWxhdGUgc3RlcCB2YWx1ZXNcclxuICAgICAgICBjb25zdCBpVmFsdWUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLmN1ckRhdGFbaWR4XS52YWx1ZSwgdGhpcy5lbmREYXRhW2lkeF0udmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGlTdGFydEFuZ2xlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5jdXJEYXRhW2lkeF0uc3RhcnRBbmdsZSwgdGhpcy5lbmREYXRhW2lkeF0uc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgY29uc3QgaUVuZEFuZ2xlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5jdXJEYXRhW2lkeF0uZW5kQW5nbGUsIHRoaXMuZW5kRGF0YVtpZHhdLmVuZEFuZ2xlKTtcclxuICAgICAgICBjb25zdCBpQ29sb3IgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLmN1ckRhdGFbaWR4XS5kYXRhLmNvbG9yLCB0aGlzLmVuZERhdGFbaWR4XS5kYXRhLmNvbG9yKTtcclxuICAgICAgICAvLyByZXR1cm4gZmFjdG9yeSBmdW5jdGlvbiBmb3IgYW5pbWF0aW9uIHN0ZXBzXHJcbiAgICAgICAgcmV0dXJuICh0KSA9PiB7XHJcbiAgICAgICAgICAvLyBpbnRlcnBvbGF0ZSB2YWx1ZXMgYnkgZ2l2ZW4gdHJhbnNpdGlvbiB2YWx1ZVxyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhW2lkeF0udmFsdWUgPSBpVmFsdWUodCk7XHJcbiAgICAgICAgICB0aGlzLmN1ckRhdGFbaWR4XS5zdGFydEFuZ2xlID0gaVN0YXJ0QW5nbGUodCk7XHJcbiAgICAgICAgICB0aGlzLmN1ckRhdGFbaWR4XS5lbmRBbmdsZSA9IGlFbmRBbmdsZSh0KTtcclxuICAgICAgICAgIHRoaXMuY3VyRGF0YVtpZHhdLmRhdGEuY29sb3IgPSBpQ29sb3IodCk7XHJcbiAgICAgICAgICAvLyBnZW5lcmF0ZSBuZXcgcGF0aFxyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhW2lkeF0uZGF0YS5wYXRoID0gdGhpcy5wYXRoR2VuZXJhdG9yKHRoaXMuY3VyRGF0YVtpZHhdKTtcclxuICAgICAgICAgIC8vIHJldHVybiBlbXB0eSBzdHJpbmcuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgZm9yIHR5cGVzY3JpcHQgY29tcGlsZXIuIE5vdGhpbmcgc2hvdWxkIGJlIGNoYW5nZWQgaGVyZS5cclxuICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICB9KVxyXG4gICAgICAvLyB3aGVuIHRyYW5zaXRpb24gaXMgY29tcGxldGVcclxuICAgICAgLm9uKCdlbmQnLCAoYXJnMCwgaWR4LCBub2RlTGlzdCkgPT4ge1xyXG4gICAgICAgIC8vIHdoZW4gdHJhbnNpdGlvbiBpcyBjb21wbGV0ZSBmb3IgdGhlIGxhc3QgaXRlbVxyXG4gICAgICAgIGlmKGlkeD09PW5vZGVMaXN0Lmxlbmd0aC0xKXtcclxuICAgICAgICAgIC8vIHJlbW92ZSBhcyBkZWxldGVkIG1hcmtlZCBlbnRyaWVzXHJcbiAgICAgICAgICB0aGlzLmNsZWFuU3RhdGVJdGVtcygpO1xyXG4gICAgICAgICAgLy8gRGVsZXRlIGludGVydXB0IGRlZmluaXRpb24sIGJlY2F1c2UgZXZlcnl0aGluZyBoYXMgZmluaXNoZWQgYW5kIG5vdGhpbmcgY2FuIGJlIGludGVycnVwdGVkLlxyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJydXB0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdHJhbnNpdGlvbiBlbmRzIHRvIHJlbW92ZSBlbnRyaWVzIGluIGN1ckRhdGEgYW5kIGVuZERhdGEgd2hpY2ggYXJlIG1hcmtlZFxyXG4gICAqIGFzIGRlbGV0ZWQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNsZWFuU3RhdGVJdGVtcygpOiB2b2lkIHtcclxuICAgIC8vIGNsZWFuIGN1cnJlbnQgc3RhdGUgYXJyYXlcclxuICAgIGZvcihsZXQgaT10aGlzLmN1ckRhdGEubGVuZ3RoLTE7IGk+PTA7IC0taSl7XHJcbiAgICAgIGlmKHRoaXMuY3VyRGF0YVtpXS5kYXRhLmRlbGV0ZWQ9PT10cnVlKXtcclxuICAgICAgICB0aGlzLmN1ckRhdGEuc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjbGVhbiBlbmQgc3RhdGUgYXJyYXlcclxuICAgIGZvcihsZXQgaT10aGlzLmVuZERhdGEubGVuZ3RoLTE7IGk+PTA7IC0taSl7XHJcbiAgICAgIGlmKHRoaXMuZW5kRGF0YVtpXS5kYXRhLmRlbGV0ZWQ9PT10cnVlKXtcclxuICAgICAgICB0aGlzLmVuZERhdGEuc3BsaWNlKGksMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBhbGwgaXRlbXMgaGF2ZSBhc3NpZ25lZCBjb2xvciB2YWx1ZXMgYW5kIGlmIG5lY2Vzc2FyeSBjb21wbGV0ZXMgY29sb3JzIGluIGdpdmVuIGRhdGEgYXJyYXkuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGluaXRDb2xvcnMoKTogdm9pZCB7XHJcbiAgICAvLyBsb29wIGFsbCBlbnRyaWVzXHJcbiAgICB0aGlzLmRhdGEuZm9yRWFjaCggKGl0ZW0pID0+IHtcclxuICAgICAgLy8gaWYgbm8gY29sb3IgaXMgYXNzaWduZWRcclxuICAgICAgaWYoIWl0ZW0uY29sb3Ipe1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIHJhbmRvbSBjb2xvciBmb3IgaXRlbVxyXG4gICAgICAgIGl0ZW0uY29sb3IgPSB0aGlzLmdlbmVyYXRlUmFuZG9tQ29sb3IoaXRlbS52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbWF4aW1hbCBhbmdsZSBvZiBjdXJyZW50IHN0YXRlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRNYXhBbmdsZSgpOiBudW1iZXIge1xyXG4gICAgbGV0IG1heEFuZ2xlID0gMDtcclxuICAgIHRoaXMuY3VyRGF0YS5mb3JFYWNoKCAoY3VySXRlbSkgPT4geyBcclxuICAgICAgaWYoY3VySXRlbS5lbmRBbmdsZSA+IG1heEFuZ2xlKXtcclxuICAgICAgICBtYXhBbmdsZSA9IGN1ckl0ZW0uZW5kQW5nbGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1heEFuZ2xlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYW5nbGVzIGZvciBjdXJyZW50IGFuZCBlbmQgc3RhdGUgaXRlbXMuXHJcbiAgICogQHBhcmFtIG1heEFuZ2xlIGxhc3QgbWF4aW1hbCBhbmdsZSBpbiBjdXJyZW50IHN0YXRlIHRvIGF2b2lkIFwianVtcGluZ1wiIHRyYW5zaXRpb25zXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNhbGN1bGF0ZUFuZ2xlcyhtYXhBbmdsZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVzIGZvciBjdXJyZW50IHN0YXRlIGl0ZW1zXHJcbiAgICB7XHJcbiAgICAgIC8vIGNhbGN1bGF0ZSBzdW0gb2YgdmFsdWVzXHJcbiAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5jdXJEYXRhLnJlZHVjZSgocCwgYykgPT4gcCArIGMudmFsdWUsIDApO1xyXG4gICAgICAvLyBsb29wIGl0ZW1zIGFuZCBjYWxjdWxhdGUgc3RhcnQgYW5kIGVuZCBhbmdsZXMsIGluaXRpYWxpemUgcmVuZGVyaW5nXHJcbiAgICAgIGxldCBsYXN0QW5nbGUgPSAwO1xyXG4gICAgICB0aGlzLmN1ckRhdGEuZm9yRWFjaCggKGl0ZW0sIGlkeCkgPT4ge1xyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhbmdsZXMgYnkgbGFzdCB1c2VkIG1heGltYWwgYW5nbGUuIHdpdGhvdXQgZGF0YSAodG90YWw9MCkgc2ltdWxhdGUgMCB2YWx1ZXMsIHNvIGRyYXcgaXRlbXMgaW4gY2xvY2t3aXNlIGRpcmVjdGlvbi5cclxuICAgICAgICBjb25zdCBuZXh0QW5nbGUgPSBsYXN0QW5nbGUgKyAoKG1heEFuZ2xlKSAvICgodG90YWw9PT0wKT8xOnRvdGFsKSkgKiBpdGVtLnZhbHVlO1xyXG4gICAgICAgIGl0ZW0uc3RhcnRBbmdsZSA9IGxhc3RBbmdsZTtcclxuICAgICAgICBpdGVtLmVuZEFuZ2xlID0gbmV4dEFuZ2xlO1xyXG4gICAgICAgIGl0ZW0uaW5kZXggPSBpZHg7XHJcbiAgICAgICAgaXRlbS5kYXRhLnBhdGggPSB0aGlzLnBhdGhHZW5lcmF0b3IoaXRlbSk7XHJcbiAgICAgICAgbGFzdEFuZ2xlID0gbmV4dEFuZ2xlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGNhbGN1bGF0ZSBhbmdsZXMgZm9yIGVuZCBzdGF0ZSBpdGVtc1xyXG4gICAge1xyXG4gICAgICAvLyBjYWxjdWxhdGUgc3VtIG9mIHZhbHVlc1xyXG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuZW5kRGF0YS5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjLnZhbHVlLCAwKTtcclxuICAgICAgLy8gbG9vcCBpdGVtcyBhbmQgY2FsY3VsYXRlIHN0YXJ0IGFuZCBlbmQgYW5nbGVzLCBpbml0aWFsaXplIHJlbmRlcmluZ1xyXG4gICAgICBsZXQgbGFzdEFuZ2xlID0gMDtcclxuICAgICAgdGhpcy5lbmREYXRhLmZvckVhY2goIChpdGVtLCBpZHgpID0+IHtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgYW5nbGVzIHdpdGggY2lyY3VtZmVyZW5jZS4gd2l0aG91dCBkYXRhICh0b3RhbD0wKSBzaW11bGF0ZSAwIHZhbHVlcywgc28gZHJhdyBpdGVtcyBpbiBhbnRpLWNsb2Nrd2lzZSBkaXJlY3Rpb24uXHJcbiAgICAgICAgY29uc3QgbmV4dEFuZ2xlID0gbGFzdEFuZ2xlICsgKCgyICogTWF0aC5QSSkgLyAoKHRvdGFsPT09MCk/MTp0b3RhbCkpICogaXRlbS52YWx1ZTtcclxuICAgICAgICBpdGVtLnN0YXJ0QW5nbGUgPSBsYXN0QW5nbGU7XHJcbiAgICAgICAgaXRlbS5lbmRBbmdsZSA9IG5leHRBbmdsZTtcclxuICAgICAgICBpdGVtLmluZGV4ID0gaWR4O1xyXG4gICAgICAgIGl0ZW0uZGF0YS5wYXRoID0gdGhpcy5wYXRoR2VuZXJhdG9yKGl0ZW0pO1xyXG4gICAgICAgIGxhc3RBbmdsZSA9IG5leHRBbmdsZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqIHJlZmVyZW5jZSB0byB0b29sdGlwIGRpdiBlbGVtZW50ICovXHJcbiAgcHJpdmF0ZSB0b29sdGlwOiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgLyoqXHJcbiAgICogZmlyZWQgd2hlbiBtb3VzZSBlbnRlcnMgYSBwaWUgY2hhcnQgcGF0aCBlbGVtZW50IGFuZCBzaG93cyB0b29sdGlwXHJcbiAgICogQHBhcmFtIGV2ZW50IFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVyUGF0aChldmVudDogTW91c2VFdmVudCl7XHJcbiAgICAvLyBnZXQgdG9vbHRpcC10ZXh0IG9mIHBhdGggZWxlbWVudFxyXG4gICAgY29uc3QgdHh0ID0gKGV2ZW50LnRhcmdldCBhcyBTVkdQYXRoRWxlbWVudCkuZ2V0QXR0cmlidXRlKCd0b29sdGlwJyk7XHJcbiAgICAvLyBzaG93IHRvb2x0aXAgYW5kIGFzc2lnbiB0ZXh0XHJcbiAgICBkMy5zZWxlY3QodGhpcy50b29sdGlwKVxyXG4gICAgICAuaHRtbCh0eHQpXHJcbiAgICAgIC5zdHlsZSgnZGlzcGxheScsICdibG9jaycpXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKDI1MClcclxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgLy8gZ2V0IGluZGV4XHJcbiAgICBjb25zdCBpZHggPSBwYXJzZUludCgoZXZlbnQudGFyZ2V0IGFzIFNWR1BhdGhFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2lkeCcpLDEwKTtcclxuICAgIC8vIGdldCBjYXB0aW9uIG9mIGVsZW1lbnRcclxuICAgIGNvbnN0IGNhcHRpb24gPSB0aGlzLmN1ckRhdGFbaWR4XS5kYXRhLmNhcHRpb247XHJcbiAgICAvLyBnZXQgb3JpZ2luYWwgZGF0YSBieSBjYXB0aW9uXHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5kYXRhLmZpbHRlciggKGQpID0+IGQuY2FwdGlvbiA9PT0gY2FwdGlvbilbMF07XHJcbiAgICAvLyBpZiBkYXRhIGZvdW5kIHRoZW4gZW1pdCBjaGFydCBjbGljayBldmVudFxyXG4gICAgaWYoaXRlbSl7XHJcbiAgICAgIHRoaXMuY2hhcnRIb3Zlci5lbWl0KGl0ZW0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGZpcmVkIHdoZW4gbW91c2UgbW92ZXMgb3ZlciBhIHBpZSBjaGFydCBwYXRoIGVsZW1lbnQgYW5kIGFkanVzdHMgdG9vbHRpcFxyXG4gICAqIEBwYXJhbSBldmVudCBcclxuICAgKi9cclxuICBwdWJsaWMgbW92ZVBhdGgoZXZlbnQ6IE1vdXNlRXZlbnQpe1xyXG4gICAgLy8gYWdncmVnYXRlIHNjcm9sbCBwb3NpdGlvbnMsIGJlY2F1c2UgZXZlbnQucGFnZSogcHJvcGVydGllcyBhcmUgcmVsYXRpdmUgdG8gdG9wIGxlZnQgY29ybmVyIG9mIGRvY3VtZW50XHJcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcbiAgICBsZXQgZWxlbWVudCA9ICh0aGlzLnRvb2x0aXAucGFyZW50RWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICB3aGlsZShlbGVtZW50KXtcclxuICAgICAgb2Zmc2V0WCArPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgIG9mZnNldFkgKz0gZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBhZGp1c3QgdG9vbHRpcFxyXG4gICAgZDMuc2VsZWN0KHRoaXMudG9vbHRpcClcclxuICAgICAgLnN0eWxlKCd0b3AnLCAoZXZlbnQucGFnZVkgLSBvZmZzZXRZICsgMTApKydweCcpXHJcbiAgICAgIC5zdHlsZSgnbGVmdCcsIChldmVudC5wYWdlWCAtIG9mZnNldFggKyAxMCkrJ3B4Jyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogZmlyZWQgd2hlbiBtb3VzZSBsZWF2ZXMgYSBwaWUgY2hhcnQgcGF0aCBlbGVtZW50IGFuZCBoaWRlcyB0b29sdGlwXHJcbiAgICogQHBhcmFtIGV2ZW50IFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdXRQYXRoKGV2ZW50OiBNb3VzZUV2ZW50KXtcclxuICAgIC8vIGhpZGUgdG9vbHRpcFxyXG4gICAgZDMuc2VsZWN0KHRoaXMudG9vbHRpcClcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24oMjUwKVxyXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLDApXHJcbiAgICAgIC5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLnRvb2x0aXApLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKVxyXG4gICAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBmaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGEgcGllIGNoYXJ0IHBhdGggZWxlbWVudFxyXG4gICAqIEBwYXJhbSBldmVudCBcclxuICAgKi9cclxuICBwdWJsaWMgY2xpY2tQYXRoKGV2ZW50OiBNb3VzZUV2ZW50KXtcclxuICAgIC8vIGdldCBpbmRleFxyXG4gICAgY29uc3QgaWR4ID0gcGFyc2VJbnQoKGV2ZW50LnRhcmdldCBhcyBTVkdQYXRoRWxlbWVudCkuZ2V0QXR0cmlidXRlKCdpZHgnKSwxMCk7XHJcbiAgICAvLyBnZXQgY2FwdGlvbiBvZiBlbGVtZW50XHJcbiAgICBjb25zdCBjYXB0aW9uID0gdGhpcy5jdXJEYXRhW2lkeF0uZGF0YS5jYXB0aW9uO1xyXG4gICAgLy8gZ2V0IG9yaWdpbmFsIGRhdGEgYnkgY2FwdGlvblxyXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuZGF0YS5maWx0ZXIoIChkKSA9PiBkLmNhcHRpb24gPT09IGNhcHRpb24pWzBdO1xyXG4gICAgLy8gaWYgZGF0YSBmb3VuZCB0aGVuIGVtaXQgY2hhcnQgY2xpY2sgZXZlbnRcclxuICAgIGlmKGl0ZW0pe1xyXG4gICAgICB0aGlzLmNoYXJ0Q2xpY2suZW1pdChpdGVtKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBtYWluIHJlbmRlcmluZyBmdW5jdGlvblxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCByZW5kZXIoKTogdm9pZHtcclxuICAgIC8vIGludGVycnVwdCBwb3NzaWJsZSBydW5uaW5nIGFuaW1hdGlvbnNcclxuICAgIGlmKHRoaXMuaW50ZXJydXB0KSB0aGlzLmludGVycnVwdCgpO1xyXG4gICAgLy8gaW5pdGlhbGl6ZSBjaGFydCBjb2xvcnNcclxuICAgIHRoaXMuaW5pdENvbG9ycygpO1xyXG4gICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgdGhpcy5yYWRpdXMgPSBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xyXG4gICAgLy8gY2FsY3VsYXRlIG1pZGRsZSBvZiBjaGFydFxyXG4gICAgdGhpcy5jZW50ZXIgPSBgdHJhbnNsYXRlKCR7dGhpcy53aWR0aCAvIDJ9LCAke3RoaXMuaGVpZ2h0IC8gMn0pYDtcclxuICAgIC8vIGNyZWF0ZSBwYXRoIGdlbmVyYXRvclxyXG4gICAgdGhpcy5wYXRoR2VuZXJhdG9yID0gZDMuYXJjKCkub3V0ZXJSYWRpdXModGhpcy5yYWRpdXMtdGhpcy5vdXRlclNwYWNpbmcpLmlubmVyUmFkaXVzKHRoaXMuaW5uZXJTcGFjaW5nKTtcclxuICAgIC8vIGdldCBjdXJyZW50IG1heGltYWwgYW5nbGUsIG5lY2Vzc2FyeSB0byBhdm9pZCBcImp1bXBpbmdcIiB0cmFuc2l0aW9uc1xyXG4gICAgY29uc3QgbWF4QW5nbGUgPSB0aGlzLmdldE1heEFuZ2xlKCk7XHJcbiAgICAvLyBjaGVjayBkYXRhIGFycmF5IGZvciBkZWxldGVkIGVudHJpZXMgYW5kIGFzc2lnbiB0cmFuc2l0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgIHRoaXMuZGV0ZWN0RGVsZXRlZEVudHJpZXMoKTtcclxuICAgIC8vIGNoZWNrIGRhdGEgYXJyYXkgZm9yIGluc2VydGVkIGVudHJpZXMgYW5kIGFzc2lnbiB0cmFuc2l0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgIHRoaXMuZGV0ZWN0SW5zZXJ0ZWRFbnRyaWVzKCk7XHJcbiAgICAvLyBjaGVjayBkYXRhIGFycmF5IGZvciBtb3ZlZCBlbnRyaWVzIGFuZCBhc3NpZ24gdHJhbnNpdGlvbiBjb25maWd1cmF0aW9uXHJcbiAgICB0aGlzLmRldGVjdE1vdmVkRW50cmllcygpO1xyXG4gICAgLy8gc3luY2hyb25pemUgZGF0YSBlbnRyaWVzIHdpdGggY3VycmVudCBhbmQgZW5kIHN0YXRlIGVudHJpZXNcclxuICAgIHRoaXMuc3luY0l0ZW1zKCk7XHJcbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVzIGZvciBjdXJyZW50IGFuZCBlbmQgc3RhdGUgZW50cmllc1xyXG4gICAgdGhpcy5jYWxjdWxhdGVBbmdsZXMobWF4QW5nbGUpO1xyXG4gICAgLy8gaW1wb3J0YW50ISB1c2Ugc2V0VGltZW91dCBiZWNhdXNlIGFuZ3VsYXIgZmlyc3QgbXVzdCBleGVjIGNoYW5nZSBkZXRlY3Rpb25cclxuICAgIHNldFRpbWVvdXQoICgpID0+IHtcclxuICAgICAgLy8gc3RhcnQgY2hhbmdlIGFuaW1hdGlvbnNcclxuICAgICAgdGhpcy5hbmltYXRlQ2hhbmdlcygpO1xyXG4gICAgfSwgMCk7XHJcbiAgfTtcclxuXHJcbiAgLypcclxuICBwcml2YXRlIHZlcnNpb24xKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc3VtID0gdGhpcy5kYXRhLnJlZHVjZSgocCwgYykgPT4gcCArIGMudmFsdWUsIDApO1xyXG4gICAgbGV0IGxhc3RBbmdsZSA9IDA7XHJcbiAgICB0aGlzLmRhdGEuZm9yRWFjaChkID0+IHtcclxuICAgICAgY29uc3QgbmV3QW5nbGUgPSBsYXN0QW5nbGUgKyAoKDIgKiBNYXRoLlBJKSAvIHN1bSkgKiBkLnZhbHVlO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gcGF0aCgpO1xyXG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcclxuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5yYWRpdXMsIGxhc3RBbmdsZSwgbmV3QW5nbGUsIGZhbHNlKTtcclxuICAgICAgZC5wYXRoID0gY29udGV4dC50b1N0cmluZygpO1xyXG4gICAgICBjb25zb2xlLmxvZyhkLnBhdGgpO1xyXG4gICAgICBsYXN0QW5nbGUgPSBuZXdBbmdsZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAqL1xyXG59XHJcbiJdfQ==