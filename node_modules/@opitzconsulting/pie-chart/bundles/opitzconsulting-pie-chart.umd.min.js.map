{"version":3,"sources":["ng://@opitzconsulting/pie-chart/lib/pie-chart.service.ts","ng://@opitzconsulting/pie-chart/lib/pie-chart.component.ts","ng://@opitzconsulting/pie-chart/lib/pie-chart.module.ts"],"names":["PieChartService","Injectable","args","providedIn","PieChartComponent","element","this","EventEmitter","undefined","prototype","deepCopy","v","JSON","parse","stringify","ngOnInit","tooltip","nativeElement","querySelector","ngOnChanges","changes","detectDataChange","ngDoCheck","dataChanged","data","length","lastData","idx","a","b","caption","color","value","render","generateRandomColor","hue2rgb","p","q","t","uniqueColorGenerated","h","Math","random","l","r","g","round","toString","map","d","filter","generatePieArcData","item","index","startAngle","endAngle","result","padAngle","innerRadius","radius","outerRadius","path","pathGenerator","detectDeletedEntries","_this","curData","forEach","curItem","deleted","endData","detectInsertedEntries","splice","detectMovedEntries","curIndex","syncItems","i","animateChanges","svg","paths","d3.select","selectAll","interrupt","transition","duration","attrTween","arg0","nodeList","iValue","d3.interpolate","iStartAngle","iEndAngle","iColor","on","cleanStateItems","initColors","getMaxAngle","maxAngle","calculateAngles","total_1","reduce","c","lastAngle_1","nextAngle","total_2","lastAngle_2","PI","overPath","event","txt","getAttribute","html","style","parseInt","chartHover","emit","movePath","offsetX","offsetY","scrollLeft","scrollTop","parentElement","pageY","pageX","outPath","clickPath","chartClick","min","width","height","center","d3.arc","outerSpacing","innerSpacing","setTimeout","Component","selector","template","styles","ElementRef","Input","Output","PieChartModule","NgModule","imports","BrowserModule","declarations","exports"],"mappings":"6bAAA,IAAAA,EAAA,WAOE,SAAAA,gCALDC,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY,sJAHd,GCAAC,EAAA,WAkFE,SAAAA,EACUC,GAAAC,KAAAD,QAAAA,YA5C2B,cAEpB,gBAEC,kBAEE,sBAEI,oBAEA,kBAE2B,IAAIE,EAAAA,6BAEJ,IAAIA,EAAAA,0BAOxB,gBAEC,iBAIQ,kBAoPRC,iBA5OtBJ,EAAAK,UAAAC,SAAV,SAAsBC,GACpB,OAAOC,KAAKC,MAAMD,KAAKE,UAAUH,KAWnCP,EAAAK,UAAAM,SAAA,WACET,KAAKU,QAAUV,KAAKD,QAAQY,cAAcC,cAAc,0BAQ1Dd,EAAAK,UAAAU,YAAA,SAAYC,GAEVd,KAAKe,oBAMPjB,EAAAK,UAAAa,UAAA,WAEEhB,KAAKe,oBAOGjB,EAAAK,UAAAY,iBAAV,WAEE,IAAIE,EAAejB,KAAKkB,KAAKC,SAAWnB,KAAKoB,SAASD,OAEtD,IAAmB,IAAhBF,EAED,IAAI,IAAII,EAAI,EAAGA,EAAIrB,KAAKkB,KAAKC,SAAUE,EAAI,CACzC,IAAMC,EAAItB,KAAKkB,KAAKG,GACdE,EAAIvB,KAAKoB,SAASC,GAIxB,GAFAJ,EAAcA,GAAgBK,EAAEE,UAAYD,EAAEC,SAAWF,EAAEG,QAAUF,EAAEE,OAASH,EAAEI,QAAUH,EAAEG,MAE9E,MAIjBT,IAEDjB,KAAK2B,SAEL3B,KAAKoB,SAAWpB,KAAKI,SAASJ,KAAKkB,QAO7BpB,EAAAK,UAAAyB,oBAAV,SAA8BF,GAY5B,IAXA,IASID,EATEI,EAAU,SAACC,EAAWC,EAAWC,GAGrC,OAFGA,EAAI,IAAGA,GAAK,GACR,EAAJA,IAAOA,GAAK,GACZA,EAAI,EAAE,EAAUF,EAAc,GAATC,EAAID,GAASE,EAClCA,EAAI,GAAYD,EAChBC,EAAI,EAAE,EAAUF,GAAKC,EAAID,IAAM,EAAE,EAAIE,GAAK,EACtCF,GAILG,GAAuB,GACI,IAAzBA,GAA+B,CACnC,IAAMC,GAAKC,KAAKC,SAAW,kBAAqB,EAI5CN,EAAI,IADAO,GAEFC,EAAIT,EAAQC,EAFVO,GAEgBH,EAAI,EAAE,GACxBK,EAAIV,EAAQC,EAHVO,GAGgBH,GAClBX,EAAIM,EAAQC,EAJVO,GAIgBH,EAAI,EAAE,GAC9BT,EAAQ,IACJU,KAAKK,MAAU,IAAJF,GAASG,SAAS,IAC7BN,KAAKK,MAAU,IAAJD,GAASE,SAAS,IAC7BN,KAAKK,MAAU,IAAJjB,GAASkB,SAAS,IACjCR,EAA8F,IAAtEjC,KAAKkB,KAAKwB,IAAK,SAACC,GAAM,OAAAA,EAAElB,QAAOmB,OAAQ,SAACD,GAAM,OAAAA,IAAMlB,IAAON,OAErF,OAAOM,GAWC3B,EAAAK,UAAA0C,mBAAV,SAA6BC,EAAoBC,EAAerB,EAAesB,EAAoBC,GAEjG,IAAMC,EAAS,CACbhC,KAAM4B,EACNC,MAAOA,EACPrB,MAAOA,EACPsB,WAAYA,EACZC,SAAUA,EACVE,SAAU,EACVC,YAAapD,KAAKqD,OAAS,GAC3BC,YAAatD,KAAKqD,QAKpB,OAFCH,EAAmC,KAAEK,KAAOvD,KAAKwD,cAAcN,GAEzDA,GAMCpD,EAAAK,UAAAsD,qBAAV,WAAA,IAAAC,EAAA1D,KAEEA,KAAK2D,QAAQC,QAAS,SAACC,EAASxC,IAEJ,IAAvBwC,EAAQ3C,KAAK4C,UAEmF,IAA9EJ,EAAKxC,KAAK0B,OAAQ,SAACE,GAAS,OAAAA,EAAKtB,UAAYqC,EAAQ3C,KAAKM,UAASL,SAIpFuC,EAAKC,QAAQtC,GAAKH,KAAK4C,SAAU,EAEjCJ,EAAKK,QAAQ1C,GAAKH,KAAK4C,SAAU,EACjCJ,EAAKK,QAAQ1C,GAAKK,MAAQ,OASxB5B,EAAAK,UAAA6D,sBAAV,WAAA,IAAAN,EAAA1D,KAEEA,KAAKkB,KAAK0C,QAAS,SAACd,EAAMzB,GAIxB,GAFqI,IAAjHqC,EAAKC,QAAQf,OAAQ,SAACiB,GAAY,OAAuB,IAAvBA,EAAQ3C,KAAK4C,SAAkBD,EAAQ3C,KAAKM,UAAYsB,EAAKtB,UAASL,OAE9G,CAGV,IAAMwB,EAAIe,EAAKb,mBAAmBa,EAAKtD,SAAS0C,GAAOzB,EAAK,GAAI,GAAI,GACpEqC,EAAKC,QAAQM,OAAO5C,EAAK,EAAGsB,GAItBA,EAAIe,EAAKb,mBAAmBa,EAAKtD,SAAS0C,GAAOzB,EAAKyB,EAAKpB,OAAQ,GAAI,GAC7EgC,EAAKK,QAAQE,OAAO5C,EAAK,EAAGsB,OAS1B7C,EAAAK,UAAA+D,mBAAV,WAIE,IAFA,IAAIC,EAAW,EAEPpB,EAAM,EAAGA,EAAM/C,KAAKkB,KAAKC,SAAU4B,EAAM,CAE/C,KAAM/C,KAAK2D,QAAQQ,GAAUjD,KAAK4C,WAAWK,EAE7C,GAAGnE,KAAKkB,KAAK6B,GAAOvB,UAAYxB,KAAK2D,QAAQQ,GAAUjD,KAAKM,QAAQ,CAIhExB,KAAK2D,QAAQQ,GAAUjD,KAAK4C,SAAU,EAEtC9D,KAAK+D,QAAQI,GAAUjD,KAAK4C,SAAU,EACtC9D,KAAK+D,QAAQI,GAAUzC,MAAQ,EAI/B,IAAMoB,EAAO9C,KAAKI,SAASJ,KAAKkB,KAAK6B,IAC/BJ,EAAI3C,KAAK6C,mBAAmBC,GAAO,EAAG,GAAI,GAAI,GACpD9C,KAAK2D,QAAQM,OAAOE,EAAU,EAAGxB,GAI3BG,EAAO9C,KAAKI,SAASJ,KAAKkB,KAAK6B,IAC/BJ,EAAI3C,KAAK6C,mBAAmBC,GAAO,EAAGA,EAAKpB,OAAQ,GAAI,GAC7D1B,KAAK+D,QAAQE,OAAOE,EAAU,EAAGxB,KAGjCwB,IAEFA,IAOIrE,EAAAK,UAAAiE,UAAV,WAAA,IAAAV,EAAA1D,KAEEA,KAAKkB,KAAK0C,QAAS,SAACd,EAAMC,GAGxB,IADA,IAAIoB,EAAW,EACPE,EAAE,EAAGA,EAAEX,EAAKC,QAAQxC,SAAUkD,EACpC,IAAIX,EAAKC,QAAQU,GAAGnD,KAAK4C,SAAWJ,EAAKC,QAAQU,GAAGnD,KAAKM,UAAYsB,EAAKtB,QAAQ,CAChF2C,EAAWE,EACX,MAIJX,EAAKC,QAAQQ,GAAUjD,KAAKQ,MAAQoB,EAAKpB,MACzCgC,EAAKK,QAAQI,GAAUjD,KAAKQ,MAAQoB,EAAKpB,MAEzCgC,EAAKK,QAAQI,GAAUzC,MAAQoB,EAAKpB,MAEpCgC,EAAKK,QAAQI,GAAUjD,KAAKO,MAAQqB,EAAKrB,SAiBnC3B,EAAAK,UAAAmE,eAAV,WAAA,IAAAZ,EAAA1D,KAEQuE,EAAOvE,KAAKD,QAAQY,cAAcC,cAAc,OAEhD4D,EAAQC,EAAAA,OAAUF,GAAKG,UAAU,QAEvC1E,KAAK2E,UAAY,WAEfH,EAAMG,mBAECjB,EAAKiB,WAGdH,EACGI,aACAC,SAAS7E,KAAK6E,UAGdC,UAAU,kBAAmB,SAACC,EAAM1D,EAAK2D,GAExC,IAAMC,EAASC,EAAAA,YAAexB,EAAKC,QAAQtC,GAAKK,MAAOgC,EAAKK,QAAQ1C,GAAKK,OACnEyD,EAAcD,EAAAA,YAAexB,EAAKC,QAAQtC,GAAK2B,WAAYU,EAAKK,QAAQ1C,GAAK2B,YAC7EoC,EAAYF,EAAAA,YAAexB,EAAKC,QAAQtC,GAAK4B,SAAUS,EAAKK,QAAQ1C,GAAK4B,UACzEoC,EAASH,EAAAA,YAAexB,EAAKC,QAAQtC,GAAKH,KAAKO,MAAOiC,EAAKK,QAAQ1C,GAAKH,KAAKO,OAEnF,OAAO,SAACO,GASN,OAPA0B,EAAKC,QAAQtC,GAAKK,MAAQuD,EAAOjD,GACjC0B,EAAKC,QAAQtC,GAAK2B,WAAamC,EAAYnD,GAC3C0B,EAAKC,QAAQtC,GAAK4B,SAAWmC,EAAUpD,GACvC0B,EAAKC,QAAQtC,GAAKH,KAAKO,MAAQ4D,EAAOrD,GAEtC0B,EAAKC,QAAQtC,GAAKH,KAAKqC,KAAOG,EAAKF,cAAcE,EAAKC,QAAQtC,IAEvD,MAIViE,GAAG,MAAO,SAACP,EAAM1D,EAAK2D,GAElB3D,IAAM2D,EAAS7D,OAAO,IAEvBuC,EAAK6B,yBAEE7B,EAAKiB,cASV7E,EAAAK,UAAAoF,gBAAV,WAEE,IAAI,IAAIlB,EAAErE,KAAK2D,QAAQxC,OAAO,EAAM,GAAHkD,IAAQA,GACL,IAA/BrE,KAAK2D,QAAQU,GAAGnD,KAAK4C,SACtB9D,KAAK2D,QAAQM,OAAOI,EAAG,GAI3B,IAAQA,EAAErE,KAAK+D,QAAQ5C,OAAO,EAAM,GAAHkD,IAAQA,GACL,IAA/BrE,KAAK+D,QAAQM,GAAGnD,KAAK4C,SACtB9D,KAAK+D,QAAQE,OAAOI,EAAE,IAQlBvE,EAAAK,UAAAqF,WAAV,WAAA,IAAA9B,EAAA1D,KAEEA,KAAKkB,KAAK0C,QAAS,SAACd,GAEdA,EAAKrB,QAEPqB,EAAKrB,MAAQiC,EAAK9B,oBAAoBkB,EAAKpB,WAQvC5B,EAAAK,UAAAsF,YAAV,WACE,IAAIC,EAAW,EAMf,OALA1F,KAAK2D,QAAQC,QAAS,SAACC,GAClBA,EAAQZ,SAAWyC,IACpBA,EAAW7B,EAAQZ,YAGhByC,GAOC5F,EAAAK,UAAAwF,gBAAV,SAA0BD,GAA1B,IAAAhC,EAAA1D,KAIU4F,EAAQ5F,KAAK2D,QAAQkC,OAAO,SAAC/D,EAAGgE,GAAM,OAAAhE,EAAIgE,EAAEpE,OAAO,GAErDqE,EAAY,EAChB/F,KAAK2D,QAAQC,QAAS,SAACd,EAAMzB,GAE3B,IAAM2E,EAAYD,EAAa,GAAuB,IAARH,EAAW,EAAEA,GAAU9C,EAAKpB,MAC1EoB,EAAKE,WAAa+C,EAClBjD,EAAKG,SAAW+C,EAChBlD,EAAKC,MAAQ1B,EACbyB,EAAK5B,KAAKqC,KAAOG,EAAKF,cAAcV,GACpCiD,EAAYC,IAMd,IAAMC,EAAQjG,KAAK+D,QAAQ8B,OAAO,SAAC/D,EAAGgE,GAAM,OAAAhE,EAAIgE,EAAEpE,OAAO,GAErDwE,EAAY,EAChBlG,KAAK+D,QAAQH,QAAS,SAACd,EAAMzB,GAE3B,IAAM2E,EAAYE,EAAc,EAAI/D,KAAKgE,IAAgB,IAARF,EAAW,EAAEA,GAAUnD,EAAKpB,MAC7EoB,EAAKE,WAAakD,EAClBpD,EAAKG,SAAW+C,EAChBlD,EAAKC,MAAQ1B,EACbyB,EAAK5B,KAAKqC,KAAOG,EAAKF,cAAcV,GACpCoD,EAAYF,KAYXlG,EAAAK,UAAAiG,kBAASC,GAEd,IAAMC,EAAOD,EAA8B,OAAEE,aAAa,WAE1D9B,EAAAA,OAAUzE,KAAKU,SACZ8F,KAAKF,GACLG,MAAM,UAAW,SACjB7B,aACAC,SAAS,KACT4B,MAAM,UAAW,GAGpB,IAAMpF,EAAMqF,SAAUL,EAA8B,OAAEE,aAAa,OAAO,IAEpE/E,EAAUxB,KAAK2D,QAAQtC,GAAKH,KAAKM,QAEjCsB,EAAO9C,KAAKkB,KAAK0B,OAAQ,SAACD,GAAM,OAAAA,EAAEnB,UAAYA,IAAS,GAE1DsB,GACD9C,KAAK2G,WAAWC,KAAK9D,IAQlBhD,EAAAK,UAAA0G,kBAASR,GAKd,IAHA,IAAIS,EAAU,EACVC,EAAU,EACVhH,EAAWC,KAAKU,QAAoC,cAClDX,GACJ+G,GAAW/G,EAAQiH,WACnBD,GAAWhH,EAAQkH,UACnBlH,EAAUA,EAAQmH,cAGpBzC,EAAAA,OAAUzE,KAAKU,SACZ+F,MAAM,MAAQJ,EAAMc,MAAQJ,EAAU,GAAI,MAC1CN,MAAM,OAASJ,EAAMe,MAAQN,EAAU,GAAI,OAOzChH,EAAAK,UAAAkH,iBAAQhB,cAEb5B,EAAAA,OAAUzE,KAAKU,SACZkE,aACAC,SAAS,KACT4B,MAAM,UAAU,GAChBnB,GAAG,MAAO,WACTb,EAAAA,OAAUf,EAAKhD,SAAS+F,MAAM,UAAW,WAQxC3G,EAAAK,UAAAmH,mBAAUjB,GAEf,IAAMhF,EAAMqF,SAAUL,EAA8B,OAAEE,aAAa,OAAO,IAEpE/E,EAAUxB,KAAK2D,QAAQtC,GAAKH,KAAKM,QAEjCsB,EAAO9C,KAAKkB,KAAK0B,OAAQ,SAACD,GAAM,OAAAA,EAAEnB,UAAYA,IAAS,GAE1DsB,GACD9C,KAAKuH,WAAWX,KAAK9D,IAOfhD,EAAAK,UAAAwB,OAAV,WAAA,IAAA+B,EAAA1D,KAEKA,KAAK2E,WAAW3E,KAAK2E,YAExB3E,KAAKwF,aAELxF,KAAKqD,OAASlB,KAAKqF,IAAIxH,KAAKyH,MAAOzH,KAAK0H,QAAU,EAElD1H,KAAK2H,OAAS,aAAa3H,KAAKyH,MAAQ,EAAC,KAAKzH,KAAK0H,OAAS,EAAC,IAE7D1H,KAAKwD,cAAgBoE,EAAAA,MAAStE,YAAYtD,KAAKqD,OAAOrD,KAAK6H,cAAczE,YAAYpD,KAAK8H,cAE1F,IAAMpC,EAAW1F,KAAKyF,cAEtBzF,KAAKyD,uBAELzD,KAAKgE,wBAELhE,KAAKkE,qBAELlE,KAAKoE,YAELpE,KAAK2F,gBAAgBD,GAErBqC,WAAY,WAEVrE,EAAKY,kBACJ,wBA1hBN0D,EAAAA,UAASpI,KAAA,CAAC,CACTqI,SAAU,eACVC,SAAU,ocAQVC,OAAQ,CAAC,6QAnCoCC,EAAAA,4CAuC5CC,EAAAA,qBAEAA,EAAAA,sBAEAA,EAAAA,wBAEAA,EAAAA,4BAEAA,EAAAA,4BAEAA,EAAAA,0BAEAC,EAAAA,2BAEAA,EAAAA,YArDH,GCAAC,EAAA,oDAICC,EAAAA,SAAQ5I,KAAA,CAAC,CACR6I,QAAS,CAACC,EAAAA,eACVC,aAAc,CAAC7I,GACf8I,QAAS,CAAC9I,SAPZ","sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class PieChartService {\r\n\r\n  constructor() { }\r\n}\r\n","import { Component, Input, OnChanges, DoCheck, ElementRef, SimpleChanges, OnInit, Output, EventEmitter } from '@angular/core';\r\n\r\nimport * as d3 from 'd3';\r\n\r\n/** chart item properties */\r\nexport interface PieChartData {\r\n  /** value of item */\r\n  value: number;\r\n  /** caption of item (must be unique) */\r\n  caption: string;\r\n  /** optional color of item (if not set, generated automatically) */\r\n  color?: string;\r\n}\r\n\r\n/** internal chart item properties */\r\nexport interface InternalPieChartData extends PieChartData {\r\n  /** svg path for item */\r\n  path?: string;\r\n  /** delete flag for removing after transition */\r\n  deleted?: boolean;\r\n}\r\n\r\n/** internal type for optimization */\r\nexport type PieArcData = d3.PieArcDatum<InternalPieChartData> & d3.DefaultArcObject;\r\n\r\n@Component({\r\n  selector: 'oc-pie-chart',\r\n  template: `<div class=\"pie-chart-tooltip\"></div>\r\n<svg [attr.width]=\"width\" [attr.height]=\"height\">\r\n    <g [attr.transform]=\"center\">\r\n        <path *ngFor=\"let d of curData; let idx = index;\" [attr.idx]=\"idx\" \r\n            [attr.fill]=\"d.data.color\" [attr.d]=\"d.data.path\" [attr.tooltip]=\"d.data.caption\"\r\n            (mouseover)=\"overPath($event)\" (mousemove)=\"movePath($event);\" (mouseout)=\"outPath($event)\" (click)=\"clickPath($event)\" />\r\n    </g>\r\n</svg>`,\r\n  styles: [`div.pie-chart-tooltip{position:fixed;display:none;opacity:0;font:12px sans-serif;color:#fff;background-color:rgba(35,47,52,.8);padding:5px}path{opacity:.7;stroke:#fff;stroke-width:2px}path:hover{opacity:1;stroke:#e3e3e3}`]\r\n})\r\nexport class PieChartComponent implements OnInit, OnChanges, DoCheck {\r\n  /** chart data, which should be displayed */\r\n  @Input() data: Array<PieChartData> = [];\r\n  /** chart width in pixel */\r\n  @Input() width = 250;\r\n  /** chart height in pixel */\r\n  @Input() height = 250;\r\n  /** duration of animation transition */\r\n  @Input() duration = 1000;\r\n  /** inner spacing in pixel, if greater than 0 it defines the radius of the empty circle in the middle */\r\n  @Input() innerSpacing = 0;\r\n  /** outer spacing in pixel */\r\n  @Input() outerSpacing = 1;\r\n  /** fired when user clicks on a chart entry */\r\n  @Output() chartClick: EventEmitter<PieChartData> = new EventEmitter();\r\n  /** fired when user hovers a chart entry */\r\n  @Output() chartHover: EventEmitter<PieChartData> = new EventEmitter();\r\n\r\n  /** pie chart radius in pixel */\r\n  public radius: number;\r\n  /** transform-attribute to center chart vertical and horizontal */\r\n  public center: string;\r\n  /** current chart data with angle and path definitions, it will be consistent to the representation */\r\n  public curData: PieArcData[] = [];\r\n  /** end chart data with angle and path definitions, it will representate the end state and used only for interpolation */\r\n  private endData: PieArcData[] = [];\r\n  /** path generator function (internal use only) */\r\n  protected pathGenerator: d3.Arc<any, d3.DefaultArcObject>;\r\n  /** copy of last processed data, used to identify changes in ngDoCheck that Angular overlooked */\r\n  private lastData: Array<PieChartData> = [];\r\n\r\n  /**\r\n   * Creates a deep copy of an variable. Do not use this function with recursive objects or\r\n   * browser objects like window or document.\r\n   * ToDo: should be outsourced.\r\n   * @param v \r\n   */\r\n  protected deepCopy<T>(v: T): T {\r\n    return JSON.parse(JSON.stringify(v));\r\n  };\r\n\r\n  /**\r\n   * constructor\r\n   * @param element \r\n   */\r\n  constructor(\r\n    private element: ElementRef\r\n  ) {};\r\n\r\n  ngOnInit() {\r\n    this.tooltip = this.element.nativeElement.querySelector('div.pie-chart-tooltip') as HTMLDivElement;\r\n  }\r\n\r\n  /**\r\n   * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.\r\n   * Angular only checks references.\r\n   * @param changes \r\n   */\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    // check if entries in bound data property has changed\r\n    this.detectDataChange();\r\n  };\r\n\r\n  /**\r\n   * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.\r\n   */\r\n  ngDoCheck() {\r\n    // check if entries in bound data property has changed\r\n    this.detectDataChange();\r\n  };\r\n\r\n  /**\r\n   * Checks whether the data property has changed. This function also check whether only an item property has\r\n   * changed. In case of change the chart will be rendered.\r\n   */\r\n  protected detectDataChange() {\r\n    // fast check: if items were added or removed\r\n    let dataChanged = (this.data.length !== this.lastData.length);\r\n    // detail check:\r\n    if(dataChanged === false){\r\n      // loop all items\r\n      for(let idx=0; idx<this.data.length; ++idx){\r\n        const a = this.data[idx];\r\n        const b = this.lastData[idx];\r\n        // check internal item properties\r\n        dataChanged = dataChanged || (a.caption !== b.caption || a.color !== b.color || a.value !== b.value);\r\n        // for optimization, stop if change detected\r\n        if(dataChanged) break;\r\n      }\r\n    }\r\n    // if change detected\r\n    if(dataChanged){\r\n      // render chart\r\n      this.render();\r\n      // copy current data to identify changes\r\n      this.lastData = this.deepCopy(this.data);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Generates a random color for a chart item.\r\n   */\r\n  protected generateRandomColor(value: number): string {\r\n    const hue2rgb = (p: number, q: number, t: number) => {\r\n      if(t < 0) t += 1; \r\n      if(t > 1) t -= 1; \r\n      if(t < 1/6) return p + (q - p) * 6 * t;\r\n      if(t < 1/2) return q;\r\n      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n      return p;\r\n    };\r\n    // make sure, generated color does not exists yet in data array\r\n    let color;\r\n    let uniqueColorGenerated = false;\r\n    while(uniqueColorGenerated === false){\r\n      const h = (Math.random() + 0.618033988749895) % 1;\r\n      const s = .5;\r\n      const l = .6;\r\n      let q = l + s - l * s;\r\n      let p = 2 * l - q;\r\n      const r = hue2rgb(p, q, h + 1/3);\r\n      const g = hue2rgb(p, q, h);\r\n      const b = hue2rgb(p, q, h - 1/3);\r\n      color = '#' \r\n        + Math.round(r * 255).toString(16)\r\n        + Math.round(g * 255).toString(16)\r\n        + Math.round(b * 255).toString(16);\r\n      uniqueColorGenerated = (this.data.map( (d) => d.color).filter( (d) => d === color).length === 0);\r\n    }\r\n    return color;\r\n  };\r\n\r\n  /**\r\n   * generates a pie chart item definition\r\n   * @param item \r\n   * @param index \r\n   * @param value \r\n   * @param startAngle \r\n   * @param endAngle \r\n   */\r\n  protected generatePieArcData(item: PieChartData, index: number, value: number, startAngle: number, endAngle: number): PieArcData {\r\n    // generate definition\r\n    const result = {\r\n      data: item,\r\n      index: index,\r\n      value: value,\r\n      startAngle: startAngle,\r\n      endAngle: endAngle,\r\n      padAngle: 0,\r\n      innerRadius: this.radius - 40,\r\n      outerRadius: this.radius\r\n    };\r\n    // generate svg path d-attribute from definition\r\n    (result.data as InternalPieChartData).path = this.pathGenerator(result);\r\n    // return definition\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks whether items were deleted and initiate delete transition for these items.\r\n   */\r\n  protected detectDeletedEntries() {\r\n    // loop current state entries\r\n    this.curData.forEach( (curItem, idx) => {\r\n      // only check if current entry is not marked as deleted\r\n      if(curItem.data.deleted!==true){\r\n        // check if entry not exists anymore\r\n        const isDeleted = (this.data.filter( (item) => item.caption === curItem.data.caption).length === 0);\r\n        // if entry is deleted\r\n        if(isDeleted){\r\n          // mark entry in current state as deleted\r\n          this.curData[idx].data.deleted = true;\r\n          // mark entry in end state as deleted and set value to 0 for transtion\r\n          this.endData[idx].data.deleted = true;\r\n          this.endData[idx].value = 0;\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks whether items were inserted and initiate insert transition for these items.\r\n   */\r\n  protected detectInsertedEntries(): void {\r\n    // loop given data array\r\n    this.data.forEach( (item, idx) => {\r\n      // check if entry is new\r\n      const isInserted = (this.curData.filter( (curItem) => curItem.data.deleted!==true && curItem.data.caption === item.caption).length===0);\r\n      // if entry is new\r\n      if(isInserted){\r\n        // generate current state entry with value of 0 for transition\r\n        {\r\n          const d = this.generatePieArcData(this.deepCopy(item), idx, 0, -1, -1);\r\n          this.curData.splice(idx, 0, d);\r\n        }\r\n        // generate end state entry with given value\r\n        {\r\n          const d = this.generatePieArcData(this.deepCopy(item), idx, item.value, -1, -1);\r\n          this.endData.splice(idx, 0, d);\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks whether items were moved and initiate transition for these items.\r\n   */\r\n  protected detectMovedEntries(): void {\r\n    // separate index in current state array\r\n    let curIndex = 0;\r\n    // loop data array\r\n    for(let index=0; index<this.data.length; ++index){\r\n      // find next index in current state array, skip items marked as deleted\r\n      while(this.curData[curIndex].data.deleted) ++curIndex; \r\n      // check if item is moved by comparing captions\r\n      if(this.data[index].caption !== this.curData[curIndex].data.caption){\r\n        // updating state items\r\n        {\r\n          // mark item in current state array as deleted\r\n          this.curData[curIndex].data.deleted = true;\r\n          // mark item in end state array as deleted and set value to 0 for transition\r\n          this.endData[curIndex].data.deleted = true;\r\n          this.endData[curIndex].value = 0;\r\n        }\r\n        // insert entry in current state array with value 0 for transition\r\n        {\r\n          const item = this.deepCopy(this.data[index]);\r\n          const d = this.generatePieArcData(item, -1, 0, -1, -1);\r\n          this.curData.splice(curIndex, 0, d);\r\n        }\r\n        // insert entry in end state array with given value\r\n        {\r\n          const item = this.deepCopy(this.data[index]);\r\n          const d = this.generatePieArcData(item, -1, item.value, -1, -1);\r\n          this.endData.splice(curIndex, 0, d);\r\n        }\r\n        // because of inserting item to the array's, increment index twice\r\n        ++curIndex;\r\n      }\r\n      ++curIndex;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Synchronize state arrays (curData / endData) with given items (data).\r\n   */\r\n  protected syncItems(): void {\r\n    // sync values and colors\r\n    this.data.forEach( (item, index) => {\r\n      // find item index in state array's\r\n      let curIndex = 0;\r\n      for(let i=0; i<this.curData.length; ++i){\r\n        if(!this.curData[i].data.deleted && this.curData[i].data.caption === item.caption){\r\n          curIndex = i;\r\n          break;\r\n        }\r\n      }\r\n      // update value in state entries\r\n      this.curData[curIndex].data.value = item.value;\r\n      this.endData[curIndex].data.value = item.value;\r\n      // update value in end state entry for transition\r\n      this.endData[curIndex].value = item.value;\r\n      // update color in end state entry for transition\r\n      this.endData[curIndex].data.color = item.color;\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Function for interrupt a running chart animation. Necessary because if transition is still active\r\n   * when a new transition is started, tween factory function from previos transition will still be fired \r\n   * until end of transition is reached. For entries which have a started transition the tween factory\r\n   * function will be fired multiple times with different tween interpolation range!\r\n   */\r\n  protected interrupt: Function = undefined;\r\n\r\n  /**\r\n   * will be triggerd to animate chart changes.\r\n   * important! this method musst be called within a setTimeout function because of angulars \r\n   * rendering cycle.\r\n   */\r\n  protected animateChanges(): void {\r\n    // get svg element reference\r\n    const svg = (this.element.nativeElement.querySelector('svg') as SVGElement);\r\n    // reference all path elements in svg element\r\n    const paths = d3.select(svg).selectAll('path');\r\n    // define interruption function to stop running animations\r\n    this.interrupt = () => {\r\n      // call paths interrupt method\r\n      paths.interrupt();\r\n      // delete interupt definition\r\n      delete this.interrupt;\r\n    };\r\n    // start path animation\r\n    paths\r\n      .transition()\r\n      .duration(this.duration)\r\n      // Use d3 attrTween transition method with dummy attribute. Make sure the dummy attribute does not\r\n      // exists at path elements!\r\n      .attrTween('pie-tween-dummy', (arg0, idx, nodeList) => {\r\n        // create interpolation functions to calculate step values\r\n        const iValue = d3.interpolate(this.curData[idx].value, this.endData[idx].value);\r\n        const iStartAngle = d3.interpolate(this.curData[idx].startAngle, this.endData[idx].startAngle);\r\n        const iEndAngle = d3.interpolate(this.curData[idx].endAngle, this.endData[idx].endAngle);\r\n        const iColor = d3.interpolate(this.curData[idx].data.color, this.endData[idx].data.color);\r\n        // return factory function for animation steps\r\n        return (t) => {\r\n          // interpolate values by given transition value\r\n          this.curData[idx].value = iValue(t);\r\n          this.curData[idx].startAngle = iStartAngle(t);\r\n          this.curData[idx].endAngle = iEndAngle(t);\r\n          this.curData[idx].data.color = iColor(t);\r\n          // generate new path\r\n          this.curData[idx].data.path = this.pathGenerator(this.curData[idx]);\r\n          // return empty string. This is only necessary for typescript compiler. Nothing should be changed here.\r\n          return '';\r\n        };\r\n      })\r\n      // when transition is complete\r\n      .on('end', (arg0, idx, nodeList) => {\r\n        // when transition is complete for the last item\r\n        if(idx===nodeList.length-1){\r\n          // remove as deleted marked entries\r\n          this.cleanStateItems();\r\n          // Delete interupt definition, because everything has finished and nothing can be interrupted.\r\n          delete this.interrupt;\r\n        }\r\n      });\r\n  };\r\n\r\n  /**\r\n   * Must be called after transition ends to remove entries in curData and endData which are marked\r\n   * as deleted.\r\n   */\r\n  protected cleanStateItems(): void {\r\n    // clean current state array\r\n    for(let i=this.curData.length-1; i>=0; --i){\r\n      if(this.curData[i].data.deleted===true){\r\n        this.curData.splice(i, 1);\r\n      }\r\n    }\r\n    // clean end state array\r\n    for(let i=this.endData.length-1; i>=0; --i){\r\n      if(this.endData[i].data.deleted===true){\r\n        this.endData.splice(i,1);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Checks whether all items have assigned color values and if necessary completes colors in given data array.\r\n   */\r\n  protected initColors(): void {\r\n    // loop all entries\r\n    this.data.forEach( (item) => {\r\n      // if no color is assigned\r\n      if(!item.color){\r\n        // generate random color for item\r\n        item.color = this.generateRandomColor(item.value);\r\n      }\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Returns maximal angle of current state items.\r\n   */\r\n  protected getMaxAngle(): number {\r\n    let maxAngle = 0;\r\n    this.curData.forEach( (curItem) => { \r\n      if(curItem.endAngle > maxAngle){\r\n        maxAngle = curItem.endAngle;\r\n      }\r\n    });\r\n    return maxAngle;\r\n  };\r\n\r\n  /**\r\n   * Calculates angles for current and end state items.\r\n   * @param maxAngle last maximal angle in current state to avoid \"jumping\" transitions\r\n   */\r\n  protected calculateAngles(maxAngle: number): void {\r\n    // calculate angles for current state items\r\n    {\r\n      // calculate sum of values\r\n      const total = this.curData.reduce((p, c) => p + c.value, 0);\r\n      // loop items and calculate start and end angles, initialize rendering\r\n      let lastAngle = 0;\r\n      this.curData.forEach( (item, idx) => {\r\n        // calculate angles by last used maximal angle. without data (total=0) simulate 0 values, so draw items in clockwise direction.\r\n        const nextAngle = lastAngle + ((maxAngle) / ((total===0)?1:total)) * item.value;\r\n        item.startAngle = lastAngle;\r\n        item.endAngle = nextAngle;\r\n        item.index = idx;\r\n        item.data.path = this.pathGenerator(item);\r\n        lastAngle = nextAngle;\r\n      });\r\n    }\r\n    // calculate angles for end state items\r\n    {\r\n      // calculate sum of values\r\n      const total = this.endData.reduce((p, c) => p + c.value, 0);\r\n      // loop items and calculate start and end angles, initialize rendering\r\n      let lastAngle = 0;\r\n      this.endData.forEach( (item, idx) => {\r\n        // calculate angles with circumference. without data (total=0) simulate 0 values, so draw items in anti-clockwise direction.\r\n        const nextAngle = lastAngle + ((2 * Math.PI) / ((total===0)?1:total)) * item.value;\r\n        item.startAngle = lastAngle;\r\n        item.endAngle = nextAngle;\r\n        item.index = idx;\r\n        item.data.path = this.pathGenerator(item);\r\n        lastAngle = nextAngle;\r\n      });\r\n    }\r\n  };\r\n\r\n  /** reference to tooltip div element */\r\n  private tooltip: HTMLDivElement;\r\n\r\n  /**\r\n   * fired when mouse enters a pie chart path element and shows tooltip\r\n   * @param event \r\n   */\r\n  public overPath(event: MouseEvent){\r\n    // get tooltip-text of path element\r\n    const txt = (event.target as SVGPathElement).getAttribute('tooltip');\r\n    // show tooltip and assign text\r\n    d3.select(this.tooltip)\r\n      .html(txt)\r\n      .style('display', 'block')\r\n      .transition()\r\n      .duration(250)\r\n      .style('opacity', 1);\r\n\r\n    // get index\r\n    const idx = parseInt((event.target as SVGPathElement).getAttribute('idx'),10);\r\n    // get caption of element\r\n    const caption = this.curData[idx].data.caption;\r\n    // get original data by caption\r\n    const item = this.data.filter( (d) => d.caption === caption)[0];\r\n    // if data found then emit chart click event\r\n    if(item){\r\n      this.chartHover.emit(item);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * fired when mouse moves over a pie chart path element and adjusts tooltip\r\n   * @param event \r\n   */\r\n  public movePath(event: MouseEvent){\r\n    // aggregate scroll positions, because event.page* properties are relative to top left corner of document\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n    let element = (this.tooltip.parentElement as HTMLElement);\r\n    while(element){\r\n      offsetX += element.scrollLeft;\r\n      offsetY += element.scrollTop;\r\n      element = element.parentElement;\r\n    }\r\n    // adjust tooltip\r\n    d3.select(this.tooltip)\r\n      .style('top', (event.pageY - offsetY + 10)+'px')\r\n      .style('left', (event.pageX - offsetX + 10)+'px');\r\n  };\r\n\r\n  /**\r\n   * fired when mouse leaves a pie chart path element and hides tooltip\r\n   * @param event \r\n   */\r\n  public outPath(event: MouseEvent){\r\n    // hide tooltip\r\n    d3.select(this.tooltip)\r\n      .transition()\r\n      .duration(250)\r\n      .style('opacity',0)\r\n      .on('end', () => {\r\n        d3.select(this.tooltip).style('display', 'none')\r\n      });\r\n  };\r\n\r\n  /**\r\n   * fired when user clicks on a pie chart path element\r\n   * @param event \r\n   */\r\n  public clickPath(event: MouseEvent){\r\n    // get index\r\n    const idx = parseInt((event.target as SVGPathElement).getAttribute('idx'),10);\r\n    // get caption of element\r\n    const caption = this.curData[idx].data.caption;\r\n    // get original data by caption\r\n    const item = this.data.filter( (d) => d.caption === caption)[0];\r\n    // if data found then emit chart click event\r\n    if(item){\r\n      this.chartClick.emit(item);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * main rendering function\r\n   */\r\n  protected render(): void{\r\n    // interrupt possible running animations\r\n    if(this.interrupt) this.interrupt();\r\n    // initialize chart colors\r\n    this.initColors();\r\n    // calculate radius\r\n    this.radius = Math.min(this.width, this.height) / 2;\r\n    // calculate middle of chart\r\n    this.center = `translate(${this.width / 2}, ${this.height / 2})`;\r\n    // create path generator\r\n    this.pathGenerator = d3.arc().outerRadius(this.radius-this.outerSpacing).innerRadius(this.innerSpacing);\r\n    // get current maximal angle, necessary to avoid \"jumping\" transitions\r\n    const maxAngle = this.getMaxAngle();\r\n    // check data array for deleted entries and assign transition configuration\r\n    this.detectDeletedEntries();\r\n    // check data array for inserted entries and assign transition configuration\r\n    this.detectInsertedEntries();\r\n    // check data array for moved entries and assign transition configuration\r\n    this.detectMovedEntries();\r\n    // synchronize data entries with current and end state entries\r\n    this.syncItems();\r\n    // calculate angles for current and end state entries\r\n    this.calculateAngles(maxAngle);\r\n    // important! use setTimeout because angular first must exec change detection\r\n    setTimeout( () => {\r\n      // start change animations\r\n      this.animateChanges();\r\n    }, 0);\r\n  };\r\n\r\n  /*\r\n  private version1(): void {\r\n    const sum = this.data.reduce((p, c) => p + c.value, 0);\r\n    let lastAngle = 0;\r\n    this.data.forEach(d => {\r\n      const newAngle = lastAngle + ((2 * Math.PI) / sum) * d.value;\r\n      const context = path();\r\n      context.moveTo(0, 0);\r\n      context.arc(0, 0, this.radius, lastAngle, newAngle, false);\r\n      d.path = context.toString();\r\n      console.log(d.path);\r\n      lastAngle = newAngle;\r\n    });\r\n  }\r\n  */\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { PieChartComponent } from './pie-chart.component';\r\nimport { BrowserModule } from '@angular/platform-browser';\r\n\r\n@NgModule({\r\n  imports: [BrowserModule],\r\n  declarations: [PieChartComponent],\r\n  exports: [PieChartComponent]\r\n})\r\nexport class PieChartModule {}\r\n"]}