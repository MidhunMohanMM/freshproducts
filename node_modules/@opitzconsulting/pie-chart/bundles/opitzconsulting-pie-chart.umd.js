(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('d3'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('@opitzconsulting/pie-chart', ['exports', '@angular/core', 'd3', '@angular/platform-browser'], factory) :
    (factory((global.opitzconsulting = global.opitzconsulting || {}, global.opitzconsulting['pie-chart'] = {}),global.ng.core,null,global.ng.platformBrowser));
}(this, (function (exports,i0,d3,platformBrowser) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PieChartService = (function () {
        function PieChartService() {
        }
        PieChartService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] },
        ];
        /** @nocollapse */
        PieChartService.ctorParameters = function () { return []; };
        /** @nocollapse */ PieChartService.ngInjectableDef = i0.defineInjectable({ factory: function PieChartService_Factory() { return new PieChartService(); }, token: PieChartService, providedIn: "root" });
        return PieChartService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PieChartComponent = (function () {
        /**
         * constructor
         * @param element
         */
        function PieChartComponent(element) {
            this.element = element;
            /**
             * chart data, which should be displayed
             */
            this.data = [];
            /**
             * chart width in pixel
             */
            this.width = 250;
            /**
             * chart height in pixel
             */
            this.height = 250;
            /**
             * duration of animation transition
             */
            this.duration = 1000;
            /**
             * inner spacing in pixel, if greater than 0 it defines the radius of the empty circle in the middle
             */
            this.innerSpacing = 0;
            /**
             * outer spacing in pixel
             */
            this.outerSpacing = 1;
            /**
             * fired when user clicks on a chart entry
             */
            this.chartClick = new i0.EventEmitter();
            /**
             * fired when user hovers a chart entry
             */
            this.chartHover = new i0.EventEmitter();
            /**
             * current chart data with angle and path definitions, it will be consistent to the representation
             */
            this.curData = [];
            /**
             * end chart data with angle and path definitions, it will representate the end state and used only for interpolation
             */
            this.endData = [];
            /**
             * copy of last processed data, used to identify changes in ngDoCheck that Angular overlooked
             */
            this.lastData = [];
            /**
             * Function for interrupt a running chart animation. Necessary because if transition is still active
             * when a new transition is started, tween factory function from previos transition will still be fired
             * until end of transition is reached. For entries which have a started transition the tween factory
             * function will be fired multiple times with different tween interpolation range!
             */
            this.interrupt = undefined;
        }
        /**
         * Creates a deep copy of an variable. Do not use this function with recursive objects or
         * browser objects like window or document.
         * ToDo: should be outsourced.
         * @param v
         */
        /**
         * Creates a deep copy of an variable. Do not use this function with recursive objects or
         * browser objects like window or document.
         * ToDo: should be outsourced.
         * @template T
         * @param {?} v
         * @return {?}
         */
        PieChartComponent.prototype.deepCopy = /**
         * Creates a deep copy of an variable. Do not use this function with recursive objects or
         * browser objects like window or document.
         * ToDo: should be outsourced.
         * @template T
         * @param {?} v
         * @return {?}
         */
            function (v) {
                return JSON.parse(JSON.stringify(v));
            };
        /**
         * @return {?}
         */
        PieChartComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.tooltip = /** @type {?} */ (this.element.nativeElement.querySelector('div.pie-chart-tooltip'));
            };
        /**
         * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.
         * Angular only checks references.
         * @param changes
         */
        /**
         * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.
         * Angular only checks references.
         * @param {?} changes
         * @return {?}
         */
        PieChartComponent.prototype.ngOnChanges = /**
         * Fired when Angular (re-)sets data-bound properties. This function does not fire when changed data in bound objects or arrays.
         * Angular only checks references.
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // check if entries in bound data property has changed
                this.detectDataChange();
            };
        /**
         * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.
         */
        /**
         * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.
         * @return {?}
         */
        PieChartComponent.prototype.ngDoCheck = /**
         * Fired during every change detection run to detect and act upon changes that Angular can't or won't detect on its own.
         * @return {?}
         */
            function () {
                // check if entries in bound data property has changed
                this.detectDataChange();
            };
        /**
         * Checks whether the data property has changed. This function also check whether only an item property has
         * changed. In case of change the chart will be rendered.
         */
        /**
         * Checks whether the data property has changed. This function also check whether only an item property has
         * changed. In case of change the chart will be rendered.
         * @return {?}
         */
        PieChartComponent.prototype.detectDataChange = /**
         * Checks whether the data property has changed. This function also check whether only an item property has
         * changed. In case of change the chart will be rendered.
         * @return {?}
         */
            function () {
                // fast check: if items were added or removed
                var /** @type {?} */ dataChanged = (this.data.length !== this.lastData.length);
                // detail check:
                if (dataChanged === false) {
                    // loop all items
                    for (var /** @type {?} */ idx = 0; idx < this.data.length; ++idx) {
                        var /** @type {?} */ a = this.data[idx];
                        var /** @type {?} */ b = this.lastData[idx];
                        // check internal item properties
                        dataChanged = dataChanged || (a.caption !== b.caption || a.color !== b.color || a.value !== b.value);
                        // for optimization, stop if change detected
                        if (dataChanged)
                            break;
                    }
                }
                // if change detected
                if (dataChanged) {
                    // render chart
                    this.render();
                    // copy current data to identify changes
                    this.lastData = this.deepCopy(this.data);
                }
            };
        /**
         * Generates a random color for a chart item.
         */
        /**
         * Generates a random color for a chart item.
         * @param {?} value
         * @return {?}
         */
        PieChartComponent.prototype.generateRandomColor = /**
         * Generates a random color for a chart item.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var /** @type {?} */ hue2rgb = function (p, q, t) {
                    if (t < 0)
                        t += 1;
                    if (t > 1)
                        t -= 1;
                    if (t < 1 / 6)
                        return p + (q - p) * 6 * t;
                    if (t < 1 / 2)
                        return q;
                    if (t < 2 / 3)
                        return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                // make sure, generated color does not exists yet in data array
                var /** @type {?} */ color;
                var /** @type {?} */ uniqueColorGenerated = false;
                while (uniqueColorGenerated === false) {
                    var /** @type {?} */ h = (Math.random() + 0.618033988749895) % 1;
                    var /** @type {?} */ s = .5;
                    var /** @type {?} */ l = .6;
                    var /** @type {?} */ q = l + s - l * s;
                    var /** @type {?} */ p = 2 * l - q;
                    var /** @type {?} */ r = hue2rgb(p, q, h + 1 / 3);
                    var /** @type {?} */ g = hue2rgb(p, q, h);
                    var /** @type {?} */ b = hue2rgb(p, q, h - 1 / 3);
                    color = '#'
                        + Math.round(r * 255).toString(16)
                        + Math.round(g * 255).toString(16)
                        + Math.round(b * 255).toString(16);
                    uniqueColorGenerated = (this.data.map(function (d) { return d.color; }).filter(function (d) { return d === color; }).length === 0);
                }
                return color;
            };
        /**
         * generates a pie chart item definition
         * @param item
         * @param index
         * @param value
         * @param startAngle
         * @param endAngle
         */
        /**
         * generates a pie chart item definition
         * @param {?} item
         * @param {?} index
         * @param {?} value
         * @param {?} startAngle
         * @param {?} endAngle
         * @return {?}
         */
        PieChartComponent.prototype.generatePieArcData = /**
         * generates a pie chart item definition
         * @param {?} item
         * @param {?} index
         * @param {?} value
         * @param {?} startAngle
         * @param {?} endAngle
         * @return {?}
         */
            function (item, index, value, startAngle, endAngle) {
                // generate definition
                var /** @type {?} */ result = {
                    data: item,
                    index: index,
                    value: value,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    padAngle: 0,
                    innerRadius: this.radius - 40,
                    outerRadius: this.radius
                };
                // generate svg path d-attribute from definition
                ((result.data)).path = this.pathGenerator(result);
                // return definition
                return result;
            };
        /**
         * Checks whether items were deleted and initiate delete transition for these items.
         */
        /**
         * Checks whether items were deleted and initiate delete transition for these items.
         * @return {?}
         */
        PieChartComponent.prototype.detectDeletedEntries = /**
         * Checks whether items were deleted and initiate delete transition for these items.
         * @return {?}
         */
            function () {
                var _this = this;
                // loop current state entries
                this.curData.forEach(function (curItem, idx) {
                    // only check if current entry is not marked as deleted
                    if (curItem.data.deleted !== true) {
                        // check if entry not exists anymore
                        var /** @type {?} */ isDeleted = (_this.data.filter(function (item) { return item.caption === curItem.data.caption; }).length === 0);
                        // if entry is deleted
                        if (isDeleted) {
                            // mark entry in current state as deleted
                            // mark entry in current state as deleted
                            _this.curData[idx].data.deleted = true;
                            // mark entry in end state as deleted and set value to 0 for transtion
                            // mark entry in end state as deleted and set value to 0 for transtion
                            _this.endData[idx].data.deleted = true;
                            _this.endData[idx].value = 0;
                        }
                    }
                });
            };
        /**
         * Checks whether items were inserted and initiate insert transition for these items.
         */
        /**
         * Checks whether items were inserted and initiate insert transition for these items.
         * @return {?}
         */
        PieChartComponent.prototype.detectInsertedEntries = /**
         * Checks whether items were inserted and initiate insert transition for these items.
         * @return {?}
         */
            function () {
                var _this = this;
                // loop given data array
                this.data.forEach(function (item, idx) {
                    // check if entry is new
                    var /** @type {?} */ isInserted = (_this.curData.filter(function (curItem) { return curItem.data.deleted !== true && curItem.data.caption === item.caption; }).length === 0);
                    // if entry is new
                    if (isInserted) {
                        {
                            var /** @type {?} */ d = _this.generatePieArcData(_this.deepCopy(item), idx, 0, -1, -1);
                            _this.curData.splice(idx, 0, d);
                        }
                        {
                            var /** @type {?} */ d = _this.generatePieArcData(_this.deepCopy(item), idx, item.value, -1, -1);
                            _this.endData.splice(idx, 0, d);
                        }
                    }
                });
            };
        /**
         * Checks whether items were moved and initiate transition for these items.
         */
        /**
         * Checks whether items were moved and initiate transition for these items.
         * @return {?}
         */
        PieChartComponent.prototype.detectMovedEntries = /**
         * Checks whether items were moved and initiate transition for these items.
         * @return {?}
         */
            function () {
                // separate index in current state array
                var /** @type {?} */ curIndex = 0;
                // loop data array
                for (var /** @type {?} */ index = 0; index < this.data.length; ++index) {
                    // find next index in current state array, skip items marked as deleted
                    while (this.curData[curIndex].data.deleted)
                        ++curIndex;
                    // check if item is moved by comparing captions
                    if (this.data[index].caption !== this.curData[curIndex].data.caption) {
                        {
                            // mark item in current state array as deleted
                            this.curData[curIndex].data.deleted = true;
                            // mark item in end state array as deleted and set value to 0 for transition
                            this.endData[curIndex].data.deleted = true;
                            this.endData[curIndex].value = 0;
                        }
                        {
                            var /** @type {?} */ item = this.deepCopy(this.data[index]);
                            var /** @type {?} */ d = this.generatePieArcData(item, -1, 0, -1, -1);
                            this.curData.splice(curIndex, 0, d);
                        }
                        {
                            var /** @type {?} */ item = this.deepCopy(this.data[index]);
                            var /** @type {?} */ d = this.generatePieArcData(item, -1, item.value, -1, -1);
                            this.endData.splice(curIndex, 0, d);
                        }
                        // because of inserting item to the array's, increment index twice
                        ++curIndex;
                    }
                    ++curIndex;
                }
            };
        /**
         * Synchronize state arrays (curData / endData) with given items (data).
         */
        /**
         * Synchronize state arrays (curData / endData) with given items (data).
         * @return {?}
         */
        PieChartComponent.prototype.syncItems = /**
         * Synchronize state arrays (curData / endData) with given items (data).
         * @return {?}
         */
            function () {
                var _this = this;
                // sync values and colors
                this.data.forEach(function (item, index) {
                    // find item index in state array's
                    var /** @type {?} */ curIndex = 0;
                    for (var /** @type {?} */ i = 0; i < _this.curData.length; ++i) {
                        if (!_this.curData[i].data.deleted && _this.curData[i].data.caption === item.caption) {
                            curIndex = i;
                            break;
                        }
                    }
                    // update value in state entries
                    // update value in state entries
                    _this.curData[curIndex].data.value = item.value;
                    _this.endData[curIndex].data.value = item.value;
                    // update value in end state entry for transition
                    // update value in end state entry for transition
                    _this.endData[curIndex].value = item.value;
                    // update color in end state entry for transition
                    // update color in end state entry for transition
                    _this.endData[curIndex].data.color = item.color;
                });
            };
        /**
         * will be triggerd to animate chart changes.
         * important! this method musst be called within a setTimeout function because of angulars
         * rendering cycle.
         */
        /**
         * will be triggerd to animate chart changes.
         * important! this method musst be called within a setTimeout function because of angulars
         * rendering cycle.
         * @return {?}
         */
        PieChartComponent.prototype.animateChanges = /**
         * will be triggerd to animate chart changes.
         * important! this method musst be called within a setTimeout function because of angulars
         * rendering cycle.
         * @return {?}
         */
            function () {
                var _this = this;
                // get svg element reference
                var /** @type {?} */ svg = ((this.element.nativeElement.querySelector('svg')));
                // reference all path elements in svg element
                var /** @type {?} */ paths = d3.select(svg).selectAll('path');
                // define interruption function to stop running animations
                this.interrupt = function () {
                    // call paths interrupt method
                    paths.interrupt();
                    // delete interupt definition
                    delete _this.interrupt;
                };
                // start path animation
                paths
                    .transition()
                    .duration(this.duration)
                    .attrTween('pie-tween-dummy', function (arg0, idx, nodeList) {
                    // create interpolation functions to calculate step values
                    var /** @type {?} */ iValue = d3.interpolate(_this.curData[idx].value, _this.endData[idx].value);
                    var /** @type {?} */ iStartAngle = d3.interpolate(_this.curData[idx].startAngle, _this.endData[idx].startAngle);
                    var /** @type {?} */ iEndAngle = d3.interpolate(_this.curData[idx].endAngle, _this.endData[idx].endAngle);
                    var /** @type {?} */ iColor = d3.interpolate(_this.curData[idx].data.color, _this.endData[idx].data.color);
                    // return factory function for animation steps
                    return function (t) {
                        // interpolate values by given transition value
                        // interpolate values by given transition value
                        _this.curData[idx].value = iValue(t);
                        _this.curData[idx].startAngle = iStartAngle(t);
                        _this.curData[idx].endAngle = iEndAngle(t);
                        _this.curData[idx].data.color = iColor(t);
                        // generate new path
                        // generate new path
                        _this.curData[idx].data.path = _this.pathGenerator(_this.curData[idx]);
                        // return empty string. This is only necessary for typescript compiler. Nothing should be changed here.
                        return '';
                    };
                })
                    .on('end', function (arg0, idx, nodeList) {
                    // when transition is complete for the last item
                    if (idx === nodeList.length - 1) {
                        // remove as deleted marked entries
                        // remove as deleted marked entries
                        _this.cleanStateItems();
                        // Delete interupt definition, because everything has finished and nothing can be interrupted.
                        delete _this.interrupt;
                    }
                });
            };
        /**
         * Must be called after transition ends to remove entries in curData and endData which are marked
         * as deleted.
         */
        /**
         * Must be called after transition ends to remove entries in curData and endData which are marked
         * as deleted.
         * @return {?}
         */
        PieChartComponent.prototype.cleanStateItems = /**
         * Must be called after transition ends to remove entries in curData and endData which are marked
         * as deleted.
         * @return {?}
         */
            function () {
                // clean current state array
                for (var /** @type {?} */ i = this.curData.length - 1; i >= 0; --i) {
                    if (this.curData[i].data.deleted === true) {
                        this.curData.splice(i, 1);
                    }
                }
                // clean end state array
                for (var /** @type {?} */ i = this.endData.length - 1; i >= 0; --i) {
                    if (this.endData[i].data.deleted === true) {
                        this.endData.splice(i, 1);
                    }
                }
            };
        /**
         * Checks whether all items have assigned color values and if necessary completes colors in given data array.
         */
        /**
         * Checks whether all items have assigned color values and if necessary completes colors in given data array.
         * @return {?}
         */
        PieChartComponent.prototype.initColors = /**
         * Checks whether all items have assigned color values and if necessary completes colors in given data array.
         * @return {?}
         */
            function () {
                var _this = this;
                // loop all entries
                this.data.forEach(function (item) {
                    // if no color is assigned
                    if (!item.color) {
                        // generate random color for item
                        item.color = _this.generateRandomColor(item.value);
                    }
                });
            };
        /**
         * Returns maximal angle of current state items.
         */
        /**
         * Returns maximal angle of current state items.
         * @return {?}
         */
        PieChartComponent.prototype.getMaxAngle = /**
         * Returns maximal angle of current state items.
         * @return {?}
         */
            function () {
                var /** @type {?} */ maxAngle = 0;
                this.curData.forEach(function (curItem) {
                    if (curItem.endAngle > maxAngle) {
                        maxAngle = curItem.endAngle;
                    }
                });
                return maxAngle;
            };
        /**
         * Calculates angles for current and end state items.
         * @param maxAngle last maximal angle in current state to avoid "jumping" transitions
         */
        /**
         * Calculates angles for current and end state items.
         * @param {?} maxAngle last maximal angle in current state to avoid "jumping" transitions
         * @return {?}
         */
        PieChartComponent.prototype.calculateAngles = /**
         * Calculates angles for current and end state items.
         * @param {?} maxAngle last maximal angle in current state to avoid "jumping" transitions
         * @return {?}
         */
            function (maxAngle) {
                var _this = this;
                {
                    // calculate sum of values
                    var /** @type {?} */ total_1 = this.curData.reduce(function (p, c) { return p + c.value; }, 0);
                    // loop items and calculate start and end angles, initialize rendering
                    var /** @type {?} */ lastAngle_1 = 0;
                    this.curData.forEach(function (item, idx) {
                        // calculate angles by last used maximal angle. without data (total=0) simulate 0 values, so draw items in clockwise direction.
                        var /** @type {?} */ nextAngle = lastAngle_1 + ((maxAngle) / ((total_1 === 0) ? 1 : total_1)) * item.value;
                        item.startAngle = lastAngle_1;
                        item.endAngle = nextAngle;
                        item.index = idx;
                        item.data.path = _this.pathGenerator(item);
                        lastAngle_1 = nextAngle;
                    });
                }
                {
                    // calculate sum of values
                    var /** @type {?} */ total_2 = this.endData.reduce(function (p, c) { return p + c.value; }, 0);
                    // loop items and calculate start and end angles, initialize rendering
                    var /** @type {?} */ lastAngle_2 = 0;
                    this.endData.forEach(function (item, idx) {
                        // calculate angles with circumference. without data (total=0) simulate 0 values, so draw items in anti-clockwise direction.
                        var /** @type {?} */ nextAngle = lastAngle_2 + ((2 * Math.PI) / ((total_2 === 0) ? 1 : total_2)) * item.value;
                        item.startAngle = lastAngle_2;
                        item.endAngle = nextAngle;
                        item.index = idx;
                        item.data.path = _this.pathGenerator(item);
                        lastAngle_2 = nextAngle;
                    });
                }
            };
        /**
         * fired when mouse enters a pie chart path element and shows tooltip
         * @param {?} event
         * @return {?}
         */
        PieChartComponent.prototype.overPath = /**
         * fired when mouse enters a pie chart path element and shows tooltip
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // get tooltip-text of path element
                var /** @type {?} */ txt = ((event.target)).getAttribute('tooltip');
                // show tooltip and assign text
                d3.select(this.tooltip)
                    .html(txt)
                    .style('display', 'block')
                    .transition()
                    .duration(250)
                    .style('opacity', 1);
                // get index
                var /** @type {?} */ idx = parseInt(((event.target)).getAttribute('idx'), 10);
                // get caption of element
                var /** @type {?} */ caption = this.curData[idx].data.caption;
                // get original data by caption
                var /** @type {?} */ item = this.data.filter(function (d) { return d.caption === caption; })[0];
                // if data found then emit chart click event
                if (item) {
                    this.chartHover.emit(item);
                }
            };
        /**
         * fired when mouse moves over a pie chart path element and adjusts tooltip
         * @param {?} event
         * @return {?}
         */
        PieChartComponent.prototype.movePath = /**
         * fired when mouse moves over a pie chart path element and adjusts tooltip
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // aggregate scroll positions, because event.page* properties are relative to top left corner of document
                var /** @type {?} */ offsetX = 0;
                var /** @type {?} */ offsetY = 0;
                var /** @type {?} */ element = ((this.tooltip.parentElement));
                while (element) {
                    offsetX += element.scrollLeft;
                    offsetY += element.scrollTop;
                    element = element.parentElement;
                }
                // adjust tooltip
                d3.select(this.tooltip)
                    .style('top', (event.pageY - offsetY + 10) + 'px')
                    .style('left', (event.pageX - offsetX + 10) + 'px');
            };
        /**
         * fired when mouse leaves a pie chart path element and hides tooltip
         * @param {?} event
         * @return {?}
         */
        PieChartComponent.prototype.outPath = /**
         * fired when mouse leaves a pie chart path element and hides tooltip
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                // hide tooltip
                d3.select(this.tooltip)
                    .transition()
                    .duration(250)
                    .style('opacity', 0)
                    .on('end', function () {
                    d3.select(_this.tooltip).style('display', 'none');
                });
            };
        /**
         * fired when user clicks on a pie chart path element
         * @param {?} event
         * @return {?}
         */
        PieChartComponent.prototype.clickPath = /**
         * fired when user clicks on a pie chart path element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // get index
                var /** @type {?} */ idx = parseInt(((event.target)).getAttribute('idx'), 10);
                // get caption of element
                var /** @type {?} */ caption = this.curData[idx].data.caption;
                // get original data by caption
                var /** @type {?} */ item = this.data.filter(function (d) { return d.caption === caption; })[0];
                // if data found then emit chart click event
                if (item) {
                    this.chartClick.emit(item);
                }
            };
        /**
         * main rendering function
         */
        /**
         * main rendering function
         * @return {?}
         */
        PieChartComponent.prototype.render = /**
         * main rendering function
         * @return {?}
         */
            function () {
                var _this = this;
                // interrupt possible running animations
                if (this.interrupt)
                    this.interrupt();
                // initialize chart colors
                this.initColors();
                // calculate radius
                this.radius = Math.min(this.width, this.height) / 2;
                // calculate middle of chart
                this.center = "translate(" + this.width / 2 + ", " + this.height / 2 + ")";
                // create path generator
                this.pathGenerator = d3.arc().outerRadius(this.radius - this.outerSpacing).innerRadius(this.innerSpacing);
                // get current maximal angle, necessary to avoid "jumping" transitions
                var /** @type {?} */ maxAngle = this.getMaxAngle();
                // check data array for deleted entries and assign transition configuration
                this.detectDeletedEntries();
                // check data array for inserted entries and assign transition configuration
                this.detectInsertedEntries();
                // check data array for moved entries and assign transition configuration
                this.detectMovedEntries();
                // synchronize data entries with current and end state entries
                this.syncItems();
                // calculate angles for current and end state entries
                this.calculateAngles(maxAngle);
                // important! use setTimeout because angular first must exec change detection
                setTimeout(function () {
                    // start change animations
                    // start change animations
                    _this.animateChanges();
                }, 0);
            };
        PieChartComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'oc-pie-chart',
                        template: "<div class=\"pie-chart-tooltip\"></div>\n<svg [attr.width]=\"width\" [attr.height]=\"height\">\n    <g [attr.transform]=\"center\">\n        <path *ngFor=\"let d of curData; let idx = index;\" [attr.idx]=\"idx\" \n            [attr.fill]=\"d.data.color\" [attr.d]=\"d.data.path\" [attr.tooltip]=\"d.data.caption\"\n            (mouseover)=\"overPath($event)\" (mousemove)=\"movePath($event);\" (mouseout)=\"outPath($event)\" (click)=\"clickPath($event)\" />\n    </g>\n</svg>",
                        styles: ["div.pie-chart-tooltip{position:fixed;display:none;opacity:0;font:12px sans-serif;color:#fff;background-color:rgba(35,47,52,.8);padding:5px}path{opacity:.7;stroke:#fff;stroke-width:2px}path:hover{opacity:1;stroke:#e3e3e3}"]
                    },] },
        ];
        /** @nocollapse */
        PieChartComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        PieChartComponent.propDecorators = {
            data: [{ type: i0.Input }],
            width: [{ type: i0.Input }],
            height: [{ type: i0.Input }],
            duration: [{ type: i0.Input }],
            innerSpacing: [{ type: i0.Input }],
            outerSpacing: [{ type: i0.Input }],
            chartClick: [{ type: i0.Output }],
            chartHover: [{ type: i0.Output }]
        };
        return PieChartComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PieChartModule = (function () {
        function PieChartModule() {
        }
        PieChartModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [platformBrowser.BrowserModule],
                        declarations: [PieChartComponent],
                        exports: [PieChartComponent]
                    },] },
        ];
        return PieChartModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.PieChartService = PieChartService;
    exports.PieChartComponent = PieChartComponent;
    exports.PieChartModule = PieChartModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BpdHpjb25zdWx0aW5nLXBpZS1jaGFydC51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BvcGl0emNvbnN1bHRpbmcvcGllLWNoYXJ0L2xpYi9waWUtY2hhcnQuc2VydmljZS50cyIsIm5nOi8vQG9waXR6Y29uc3VsdGluZy9waWUtY2hhcnQvbGliL3BpZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0BvcGl0emNvbnN1bHRpbmcvcGllLWNoYXJ0L2xpYi9waWUtY2hhcnQubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIFBpZUNoYXJ0U2VydmljZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkgeyB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBEb0NoZWNrLCBFbGVtZW50UmVmLCBTaW1wbGVDaGFuZ2VzLCBPbkluaXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XHJcblxyXG4vKiogY2hhcnQgaXRlbSBwcm9wZXJ0aWVzICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGllQ2hhcnREYXRhIHtcclxuICAvKiogdmFsdWUgb2YgaXRlbSAqL1xyXG4gIHZhbHVlOiBudW1iZXI7XHJcbiAgLyoqIGNhcHRpb24gb2YgaXRlbSAobXVzdCBiZSB1bmlxdWUpICovXHJcbiAgY2FwdGlvbjogc3RyaW5nO1xyXG4gIC8qKiBvcHRpb25hbCBjb2xvciBvZiBpdGVtIChpZiBub3Qgc2V0LCBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSkgKi9cclxuICBjb2xvcj86IHN0cmluZztcclxufVxyXG5cclxuLyoqIGludGVybmFsIGNoYXJ0IGl0ZW0gcHJvcGVydGllcyAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsUGllQ2hhcnREYXRhIGV4dGVuZHMgUGllQ2hhcnREYXRhIHtcclxuICAvKiogc3ZnIHBhdGggZm9yIGl0ZW0gKi9cclxuICBwYXRoPzogc3RyaW5nO1xyXG4gIC8qKiBkZWxldGUgZmxhZyBmb3IgcmVtb3ZpbmcgYWZ0ZXIgdHJhbnNpdGlvbiAqL1xyXG4gIGRlbGV0ZWQ/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKiogaW50ZXJuYWwgdHlwZSBmb3Igb3B0aW1pemF0aW9uICovXHJcbmV4cG9ydCB0eXBlIFBpZUFyY0RhdGEgPSBkMy5QaWVBcmNEYXR1bTxJbnRlcm5hbFBpZUNoYXJ0RGF0YT4gJiBkMy5EZWZhdWx0QXJjT2JqZWN0O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdvYy1waWUtY2hhcnQnLFxyXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBpZS1jaGFydC10b29sdGlwXCI+PC9kaXY+XHJcbjxzdmcgW2F0dHIud2lkdGhdPVwid2lkdGhcIiBbYXR0ci5oZWlnaHRdPVwiaGVpZ2h0XCI+XHJcbiAgICA8ZyBbYXR0ci50cmFuc2Zvcm1dPVwiY2VudGVyXCI+XHJcbiAgICAgICAgPHBhdGggKm5nRm9yPVwibGV0IGQgb2YgY3VyRGF0YTsgbGV0IGlkeCA9IGluZGV4O1wiIFthdHRyLmlkeF09XCJpZHhcIiBcclxuICAgICAgICAgICAgW2F0dHIuZmlsbF09XCJkLmRhdGEuY29sb3JcIiBbYXR0ci5kXT1cImQuZGF0YS5wYXRoXCIgW2F0dHIudG9vbHRpcF09XCJkLmRhdGEuY2FwdGlvblwiXHJcbiAgICAgICAgICAgIChtb3VzZW92ZXIpPVwib3ZlclBhdGgoJGV2ZW50KVwiIChtb3VzZW1vdmUpPVwibW92ZVBhdGgoJGV2ZW50KTtcIiAobW91c2VvdXQpPVwib3V0UGF0aCgkZXZlbnQpXCIgKGNsaWNrKT1cImNsaWNrUGF0aCgkZXZlbnQpXCIgLz5cclxuICAgIDwvZz5cclxuPC9zdmc+YCxcclxuICBzdHlsZXM6IFtgZGl2LnBpZS1jaGFydC10b29sdGlwe3Bvc2l0aW9uOmZpeGVkO2Rpc3BsYXk6bm9uZTtvcGFjaXR5OjA7Zm9udDoxMnB4IHNhbnMtc2VyaWY7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMzUsNDcsNTIsLjgpO3BhZGRpbmc6NXB4fXBhdGh7b3BhY2l0eTouNztzdHJva2U6I2ZmZjtzdHJva2Utd2lkdGg6MnB4fXBhdGg6aG92ZXJ7b3BhY2l0eToxO3N0cm9rZTojZTNlM2UzfWBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQaWVDaGFydENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrIHtcclxuICAvKiogY2hhcnQgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGRpc3BsYXllZCAqL1xyXG4gIEBJbnB1dCgpIGRhdGE6IEFycmF5PFBpZUNoYXJ0RGF0YT4gPSBbXTtcclxuICAvKiogY2hhcnQgd2lkdGggaW4gcGl4ZWwgKi9cclxuICBASW5wdXQoKSB3aWR0aCA9IDI1MDtcclxuICAvKiogY2hhcnQgaGVpZ2h0IGluIHBpeGVsICovXHJcbiAgQElucHV0KCkgaGVpZ2h0ID0gMjUwO1xyXG4gIC8qKiBkdXJhdGlvbiBvZiBhbmltYXRpb24gdHJhbnNpdGlvbiAqL1xyXG4gIEBJbnB1dCgpIGR1cmF0aW9uID0gMTAwMDtcclxuICAvKiogaW5uZXIgc3BhY2luZyBpbiBwaXhlbCwgaWYgZ3JlYXRlciB0aGFuIDAgaXQgZGVmaW5lcyB0aGUgcmFkaXVzIG9mIHRoZSBlbXB0eSBjaXJjbGUgaW4gdGhlIG1pZGRsZSAqL1xyXG4gIEBJbnB1dCgpIGlubmVyU3BhY2luZyA9IDA7XHJcbiAgLyoqIG91dGVyIHNwYWNpbmcgaW4gcGl4ZWwgKi9cclxuICBASW5wdXQoKSBvdXRlclNwYWNpbmcgPSAxO1xyXG4gIC8qKiBmaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGEgY2hhcnQgZW50cnkgKi9cclxuICBAT3V0cHV0KCkgY2hhcnRDbGljazogRXZlbnRFbWl0dGVyPFBpZUNoYXJ0RGF0YT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgLyoqIGZpcmVkIHdoZW4gdXNlciBob3ZlcnMgYSBjaGFydCBlbnRyeSAqL1xyXG4gIEBPdXRwdXQoKSBjaGFydEhvdmVyOiBFdmVudEVtaXR0ZXI8UGllQ2hhcnREYXRhPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgLyoqIHBpZSBjaGFydCByYWRpdXMgaW4gcGl4ZWwgKi9cclxuICBwdWJsaWMgcmFkaXVzOiBudW1iZXI7XHJcbiAgLyoqIHRyYW5zZm9ybS1hdHRyaWJ1dGUgdG8gY2VudGVyIGNoYXJ0IHZlcnRpY2FsIGFuZCBob3Jpem9udGFsICovXHJcbiAgcHVibGljIGNlbnRlcjogc3RyaW5nO1xyXG4gIC8qKiBjdXJyZW50IGNoYXJ0IGRhdGEgd2l0aCBhbmdsZSBhbmQgcGF0aCBkZWZpbml0aW9ucywgaXQgd2lsbCBiZSBjb25zaXN0ZW50IHRvIHRoZSByZXByZXNlbnRhdGlvbiAqL1xyXG4gIHB1YmxpYyBjdXJEYXRhOiBQaWVBcmNEYXRhW10gPSBbXTtcclxuICAvKiogZW5kIGNoYXJ0IGRhdGEgd2l0aCBhbmdsZSBhbmQgcGF0aCBkZWZpbml0aW9ucywgaXQgd2lsbCByZXByZXNlbnRhdGUgdGhlIGVuZCBzdGF0ZSBhbmQgdXNlZCBvbmx5IGZvciBpbnRlcnBvbGF0aW9uICovXHJcbiAgcHJpdmF0ZSBlbmREYXRhOiBQaWVBcmNEYXRhW10gPSBbXTtcclxuICAvKiogcGF0aCBnZW5lcmF0b3IgZnVuY3Rpb24gKGludGVybmFsIHVzZSBvbmx5KSAqL1xyXG4gIHByb3RlY3RlZCBwYXRoR2VuZXJhdG9yOiBkMy5BcmM8YW55LCBkMy5EZWZhdWx0QXJjT2JqZWN0PjtcclxuICAvKiogY29weSBvZiBsYXN0IHByb2Nlc3NlZCBkYXRhLCB1c2VkIHRvIGlkZW50aWZ5IGNoYW5nZXMgaW4gbmdEb0NoZWNrIHRoYXQgQW5ndWxhciBvdmVybG9va2VkICovXHJcbiAgcHJpdmF0ZSBsYXN0RGF0YTogQXJyYXk8UGllQ2hhcnREYXRhPiA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIGFuIHZhcmlhYmxlLiBEbyBub3QgdXNlIHRoaXMgZnVuY3Rpb24gd2l0aCByZWN1cnNpdmUgb2JqZWN0cyBvclxyXG4gICAqIGJyb3dzZXIgb2JqZWN0cyBsaWtlIHdpbmRvdyBvciBkb2N1bWVudC5cclxuICAgKiBUb0RvOiBzaG91bGQgYmUgb3V0c291cmNlZC5cclxuICAgKiBAcGFyYW0gdiBcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZGVlcENvcHk8VD4odjogVCk6IFQge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodikpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWZcclxuICApIHt9O1xyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHRoaXMudG9vbHRpcCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5waWUtY2hhcnQtdG9vbHRpcCcpIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZWQgd2hlbiBBbmd1bGFyIChyZS0pc2V0cyBkYXRhLWJvdW5kIHByb3BlcnRpZXMuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgZmlyZSB3aGVuIGNoYW5nZWQgZGF0YSBpbiBib3VuZCBvYmplY3RzIG9yIGFycmF5cy5cclxuICAgKiBBbmd1bGFyIG9ubHkgY2hlY2tzIHJlZmVyZW5jZXMuXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgXHJcbiAgICovXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgLy8gY2hlY2sgaWYgZW50cmllcyBpbiBib3VuZCBkYXRhIHByb3BlcnR5IGhhcyBjaGFuZ2VkXHJcbiAgICB0aGlzLmRldGVjdERhdGFDaGFuZ2UoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGaXJlZCBkdXJpbmcgZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBydW4gdG8gZGV0ZWN0IGFuZCBhY3QgdXBvbiBjaGFuZ2VzIHRoYXQgQW5ndWxhciBjYW4ndCBvciB3b24ndCBkZXRlY3Qgb24gaXRzIG93bi5cclxuICAgKi9cclxuICBuZ0RvQ2hlY2soKSB7XHJcbiAgICAvLyBjaGVjayBpZiBlbnRyaWVzIGluIGJvdW5kIGRhdGEgcHJvcGVydHkgaGFzIGNoYW5nZWRcclxuICAgIHRoaXMuZGV0ZWN0RGF0YUNoYW5nZSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkYXRhIHByb3BlcnR5IGhhcyBjaGFuZ2VkLiBUaGlzIGZ1bmN0aW9uIGFsc28gY2hlY2sgd2hldGhlciBvbmx5IGFuIGl0ZW0gcHJvcGVydHkgaGFzXHJcbiAgICogY2hhbmdlZC4gSW4gY2FzZSBvZiBjaGFuZ2UgdGhlIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGRldGVjdERhdGFDaGFuZ2UoKSB7XHJcbiAgICAvLyBmYXN0IGNoZWNrOiBpZiBpdGVtcyB3ZXJlIGFkZGVkIG9yIHJlbW92ZWRcclxuICAgIGxldCBkYXRhQ2hhbmdlZCA9ICh0aGlzLmRhdGEubGVuZ3RoICE9PSB0aGlzLmxhc3REYXRhLmxlbmd0aCk7XHJcbiAgICAvLyBkZXRhaWwgY2hlY2s6XHJcbiAgICBpZihkYXRhQ2hhbmdlZCA9PT0gZmFsc2Upe1xyXG4gICAgICAvLyBsb29wIGFsbCBpdGVtc1xyXG4gICAgICBmb3IobGV0IGlkeD0wOyBpZHg8dGhpcy5kYXRhLmxlbmd0aDsgKytpZHgpe1xyXG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmRhdGFbaWR4XTtcclxuICAgICAgICBjb25zdCBiID0gdGhpcy5sYXN0RGF0YVtpZHhdO1xyXG4gICAgICAgIC8vIGNoZWNrIGludGVybmFsIGl0ZW0gcHJvcGVydGllc1xyXG4gICAgICAgIGRhdGFDaGFuZ2VkID0gZGF0YUNoYW5nZWQgfHwgKGEuY2FwdGlvbiAhPT0gYi5jYXB0aW9uIHx8IGEuY29sb3IgIT09IGIuY29sb3IgfHwgYS52YWx1ZSAhPT0gYi52YWx1ZSk7XHJcbiAgICAgICAgLy8gZm9yIG9wdGltaXphdGlvbiwgc3RvcCBpZiBjaGFuZ2UgZGV0ZWN0ZWRcclxuICAgICAgICBpZihkYXRhQ2hhbmdlZCkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGlmIGNoYW5nZSBkZXRlY3RlZFxyXG4gICAgaWYoZGF0YUNoYW5nZWQpe1xyXG4gICAgICAvLyByZW5kZXIgY2hhcnRcclxuICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgLy8gY29weSBjdXJyZW50IGRhdGEgdG8gaWRlbnRpZnkgY2hhbmdlc1xyXG4gICAgICB0aGlzLmxhc3REYXRhID0gdGhpcy5kZWVwQ29weSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBjb2xvciBmb3IgYSBjaGFydCBpdGVtLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZW5lcmF0ZVJhbmRvbUNvbG9yKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgaHVlMnJnYiA9IChwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmKHQgPCAwKSB0ICs9IDE7IFxyXG4gICAgICBpZih0ID4gMSkgdCAtPSAxOyBcclxuICAgICAgaWYodCA8IDEvNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xyXG4gICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xyXG4gICAgICByZXR1cm4gcDtcclxuICAgIH07XHJcbiAgICAvLyBtYWtlIHN1cmUsIGdlbmVyYXRlZCBjb2xvciBkb2VzIG5vdCBleGlzdHMgeWV0IGluIGRhdGEgYXJyYXlcclxuICAgIGxldCBjb2xvcjtcclxuICAgIGxldCB1bmlxdWVDb2xvckdlbmVyYXRlZCA9IGZhbHNlO1xyXG4gICAgd2hpbGUodW5pcXVlQ29sb3JHZW5lcmF0ZWQgPT09IGZhbHNlKXtcclxuICAgICAgY29uc3QgaCA9IChNYXRoLnJhbmRvbSgpICsgMC42MTgwMzM5ODg3NDk4OTUpICUgMTtcclxuICAgICAgY29uc3QgcyA9IC41O1xyXG4gICAgICBjb25zdCBsID0gLjY7XHJcbiAgICAgIGxldCBxID0gbCArIHMgLSBsICogcztcclxuICAgICAgbGV0IHAgPSAyICogbCAtIHE7XHJcbiAgICAgIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xyXG4gICAgICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcclxuICAgICAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XHJcbiAgICAgIGNvbG9yID0gJyMnIFxyXG4gICAgICAgICsgTWF0aC5yb3VuZChyICogMjU1KS50b1N0cmluZygxNilcclxuICAgICAgICArIE1hdGgucm91bmQoZyAqIDI1NSkudG9TdHJpbmcoMTYpXHJcbiAgICAgICAgKyBNYXRoLnJvdW5kKGIgKiAyNTUpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgdW5pcXVlQ29sb3JHZW5lcmF0ZWQgPSAodGhpcy5kYXRhLm1hcCggKGQpID0+IGQuY29sb3IpLmZpbHRlciggKGQpID0+IGQgPT09IGNvbG9yKS5sZW5ndGggPT09IDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbG9yO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGdlbmVyYXRlcyBhIHBpZSBjaGFydCBpdGVtIGRlZmluaXRpb25cclxuICAgKiBAcGFyYW0gaXRlbSBcclxuICAgKiBAcGFyYW0gaW5kZXggXHJcbiAgICogQHBhcmFtIHZhbHVlIFxyXG4gICAqIEBwYXJhbSBzdGFydEFuZ2xlIFxyXG4gICAqIEBwYXJhbSBlbmRBbmdsZSBcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2VuZXJhdGVQaWVBcmNEYXRhKGl0ZW06IFBpZUNoYXJ0RGF0YSwgaW5kZXg6IG51bWJlciwgdmFsdWU6IG51bWJlciwgc3RhcnRBbmdsZTogbnVtYmVyLCBlbmRBbmdsZTogbnVtYmVyKTogUGllQXJjRGF0YSB7XHJcbiAgICAvLyBnZW5lcmF0ZSBkZWZpbml0aW9uXHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgIGRhdGE6IGl0ZW0sXHJcbiAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG4gICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXHJcbiAgICAgIHBhZEFuZ2xlOiAwLFxyXG4gICAgICBpbm5lclJhZGl1czogdGhpcy5yYWRpdXMgLSA0MCxcclxuICAgICAgb3V0ZXJSYWRpdXM6IHRoaXMucmFkaXVzXHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGUgc3ZnIHBhdGggZC1hdHRyaWJ1dGUgZnJvbSBkZWZpbml0aW9uXHJcbiAgICAocmVzdWx0LmRhdGEgYXMgSW50ZXJuYWxQaWVDaGFydERhdGEpLnBhdGggPSB0aGlzLnBhdGhHZW5lcmF0b3IocmVzdWx0KTtcclxuICAgIC8vIHJldHVybiBkZWZpbml0aW9uXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIGl0ZW1zIHdlcmUgZGVsZXRlZCBhbmQgaW5pdGlhdGUgZGVsZXRlIHRyYW5zaXRpb24gZm9yIHRoZXNlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkZXRlY3REZWxldGVkRW50cmllcygpIHtcclxuICAgIC8vIGxvb3AgY3VycmVudCBzdGF0ZSBlbnRyaWVzXHJcbiAgICB0aGlzLmN1ckRhdGEuZm9yRWFjaCggKGN1ckl0ZW0sIGlkeCkgPT4ge1xyXG4gICAgICAvLyBvbmx5IGNoZWNrIGlmIGN1cnJlbnQgZW50cnkgaXMgbm90IG1hcmtlZCBhcyBkZWxldGVkXHJcbiAgICAgIGlmKGN1ckl0ZW0uZGF0YS5kZWxldGVkIT09dHJ1ZSl7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgZW50cnkgbm90IGV4aXN0cyBhbnltb3JlXHJcbiAgICAgICAgY29uc3QgaXNEZWxldGVkID0gKHRoaXMuZGF0YS5maWx0ZXIoIChpdGVtKSA9PiBpdGVtLmNhcHRpb24gPT09IGN1ckl0ZW0uZGF0YS5jYXB0aW9uKS5sZW5ndGggPT09IDApO1xyXG4gICAgICAgIC8vIGlmIGVudHJ5IGlzIGRlbGV0ZWRcclxuICAgICAgICBpZihpc0RlbGV0ZWQpe1xyXG4gICAgICAgICAgLy8gbWFyayBlbnRyeSBpbiBjdXJyZW50IHN0YXRlIGFzIGRlbGV0ZWRcclxuICAgICAgICAgIHRoaXMuY3VyRGF0YVtpZHhdLmRhdGEuZGVsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAvLyBtYXJrIGVudHJ5IGluIGVuZCBzdGF0ZSBhcyBkZWxldGVkIGFuZCBzZXQgdmFsdWUgdG8gMCBmb3IgdHJhbnN0aW9uXHJcbiAgICAgICAgICB0aGlzLmVuZERhdGFbaWR4XS5kYXRhLmRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5lbmREYXRhW2lkeF0udmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgaXRlbXMgd2VyZSBpbnNlcnRlZCBhbmQgaW5pdGlhdGUgaW5zZXJ0IHRyYW5zaXRpb24gZm9yIHRoZXNlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkZXRlY3RJbnNlcnRlZEVudHJpZXMoKTogdm9pZCB7XHJcbiAgICAvLyBsb29wIGdpdmVuIGRhdGEgYXJyYXlcclxuICAgIHRoaXMuZGF0YS5mb3JFYWNoKCAoaXRlbSwgaWR4KSA9PiB7XHJcbiAgICAgIC8vIGNoZWNrIGlmIGVudHJ5IGlzIG5ld1xyXG4gICAgICBjb25zdCBpc0luc2VydGVkID0gKHRoaXMuY3VyRGF0YS5maWx0ZXIoIChjdXJJdGVtKSA9PiBjdXJJdGVtLmRhdGEuZGVsZXRlZCE9PXRydWUgJiYgY3VySXRlbS5kYXRhLmNhcHRpb24gPT09IGl0ZW0uY2FwdGlvbikubGVuZ3RoPT09MCk7XHJcbiAgICAgIC8vIGlmIGVudHJ5IGlzIG5ld1xyXG4gICAgICBpZihpc0luc2VydGVkKXtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBjdXJyZW50IHN0YXRlIGVudHJ5IHdpdGggdmFsdWUgb2YgMCBmb3IgdHJhbnNpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbmVyYXRlUGllQXJjRGF0YSh0aGlzLmRlZXBDb3B5KGl0ZW0pLCBpZHgsIDAsIC0xLCAtMSk7XHJcbiAgICAgICAgICB0aGlzLmN1ckRhdGEuc3BsaWNlKGlkeCwgMCwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGdlbmVyYXRlIGVuZCBzdGF0ZSBlbnRyeSB3aXRoIGdpdmVuIHZhbHVlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuZXJhdGVQaWVBcmNEYXRhKHRoaXMuZGVlcENvcHkoaXRlbSksIGlkeCwgaXRlbS52YWx1ZSwgLTEsIC0xKTtcclxuICAgICAgICAgIHRoaXMuZW5kRGF0YS5zcGxpY2UoaWR4LCAwLCBkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyB3aGV0aGVyIGl0ZW1zIHdlcmUgbW92ZWQgYW5kIGluaXRpYXRlIHRyYW5zaXRpb24gZm9yIHRoZXNlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkZXRlY3RNb3ZlZEVudHJpZXMoKTogdm9pZCB7XHJcbiAgICAvLyBzZXBhcmF0ZSBpbmRleCBpbiBjdXJyZW50IHN0YXRlIGFycmF5XHJcbiAgICBsZXQgY3VySW5kZXggPSAwO1xyXG4gICAgLy8gbG9vcCBkYXRhIGFycmF5XHJcbiAgICBmb3IobGV0IGluZGV4PTA7IGluZGV4PHRoaXMuZGF0YS5sZW5ndGg7ICsraW5kZXgpe1xyXG4gICAgICAvLyBmaW5kIG5leHQgaW5kZXggaW4gY3VycmVudCBzdGF0ZSBhcnJheSwgc2tpcCBpdGVtcyBtYXJrZWQgYXMgZGVsZXRlZFxyXG4gICAgICB3aGlsZSh0aGlzLmN1ckRhdGFbY3VySW5kZXhdLmRhdGEuZGVsZXRlZCkgKytjdXJJbmRleDsgXHJcbiAgICAgIC8vIGNoZWNrIGlmIGl0ZW0gaXMgbW92ZWQgYnkgY29tcGFyaW5nIGNhcHRpb25zXHJcbiAgICAgIGlmKHRoaXMuZGF0YVtpbmRleF0uY2FwdGlvbiAhPT0gdGhpcy5jdXJEYXRhW2N1ckluZGV4XS5kYXRhLmNhcHRpb24pe1xyXG4gICAgICAgIC8vIHVwZGF0aW5nIHN0YXRlIGl0ZW1zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgLy8gbWFyayBpdGVtIGluIGN1cnJlbnQgc3RhdGUgYXJyYXkgYXMgZGVsZXRlZFxyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhW2N1ckluZGV4XS5kYXRhLmRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gbWFyayBpdGVtIGluIGVuZCBzdGF0ZSBhcnJheSBhcyBkZWxldGVkIGFuZCBzZXQgdmFsdWUgdG8gMCBmb3IgdHJhbnNpdGlvblxyXG4gICAgICAgICAgdGhpcy5lbmREYXRhW2N1ckluZGV4XS5kYXRhLmRlbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5lbmREYXRhW2N1ckluZGV4XS52YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluc2VydCBlbnRyeSBpbiBjdXJyZW50IHN0YXRlIGFycmF5IHdpdGggdmFsdWUgMCBmb3IgdHJhbnNpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmRlZXBDb3B5KHRoaXMuZGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuZXJhdGVQaWVBcmNEYXRhKGl0ZW0sIC0xLCAwLCAtMSwgLTEpO1xyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhLnNwbGljZShjdXJJbmRleCwgMCwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluc2VydCBlbnRyeSBpbiBlbmQgc3RhdGUgYXJyYXkgd2l0aCBnaXZlbiB2YWx1ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmRlZXBDb3B5KHRoaXMuZGF0YVtpbmRleF0pO1xyXG4gICAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuZXJhdGVQaWVBcmNEYXRhKGl0ZW0sIC0xLCBpdGVtLnZhbHVlLCAtMSwgLTEpO1xyXG4gICAgICAgICAgdGhpcy5lbmREYXRhLnNwbGljZShjdXJJbmRleCwgMCwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgaW5zZXJ0aW5nIGl0ZW0gdG8gdGhlIGFycmF5J3MsIGluY3JlbWVudCBpbmRleCB0d2ljZVxyXG4gICAgICAgICsrY3VySW5kZXg7XHJcbiAgICAgIH1cclxuICAgICAgKytjdXJJbmRleDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTeW5jaHJvbml6ZSBzdGF0ZSBhcnJheXMgKGN1ckRhdGEgLyBlbmREYXRhKSB3aXRoIGdpdmVuIGl0ZW1zIChkYXRhKS5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc3luY0l0ZW1zKCk6IHZvaWQge1xyXG4gICAgLy8gc3luYyB2YWx1ZXMgYW5kIGNvbG9yc1xyXG4gICAgdGhpcy5kYXRhLmZvckVhY2goIChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAvLyBmaW5kIGl0ZW0gaW5kZXggaW4gc3RhdGUgYXJyYXknc1xyXG4gICAgICBsZXQgY3VySW5kZXggPSAwO1xyXG4gICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLmN1ckRhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGlmKCF0aGlzLmN1ckRhdGFbaV0uZGF0YS5kZWxldGVkICYmIHRoaXMuY3VyRGF0YVtpXS5kYXRhLmNhcHRpb24gPT09IGl0ZW0uY2FwdGlvbil7XHJcbiAgICAgICAgICBjdXJJbmRleCA9IGk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gdXBkYXRlIHZhbHVlIGluIHN0YXRlIGVudHJpZXNcclxuICAgICAgdGhpcy5jdXJEYXRhW2N1ckluZGV4XS5kYXRhLnZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgdGhpcy5lbmREYXRhW2N1ckluZGV4XS5kYXRhLnZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgLy8gdXBkYXRlIHZhbHVlIGluIGVuZCBzdGF0ZSBlbnRyeSBmb3IgdHJhbnNpdGlvblxyXG4gICAgICB0aGlzLmVuZERhdGFbY3VySW5kZXhdLnZhbHVlID0gaXRlbS52YWx1ZTtcclxuICAgICAgLy8gdXBkYXRlIGNvbG9yIGluIGVuZCBzdGF0ZSBlbnRyeSBmb3IgdHJhbnNpdGlvblxyXG4gICAgICB0aGlzLmVuZERhdGFbY3VySW5kZXhdLmRhdGEuY29sb3IgPSBpdGVtLmNvbG9yO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gZm9yIGludGVycnVwdCBhIHJ1bm5pbmcgY2hhcnQgYW5pbWF0aW9uLiBOZWNlc3NhcnkgYmVjYXVzZSBpZiB0cmFuc2l0aW9uIGlzIHN0aWxsIGFjdGl2ZVxyXG4gICAqIHdoZW4gYSBuZXcgdHJhbnNpdGlvbiBpcyBzdGFydGVkLCB0d2VlbiBmYWN0b3J5IGZ1bmN0aW9uIGZyb20gcHJldmlvcyB0cmFuc2l0aW9uIHdpbGwgc3RpbGwgYmUgZmlyZWQgXHJcbiAgICogdW50aWwgZW5kIG9mIHRyYW5zaXRpb24gaXMgcmVhY2hlZC4gRm9yIGVudHJpZXMgd2hpY2ggaGF2ZSBhIHN0YXJ0ZWQgdHJhbnNpdGlvbiB0aGUgdHdlZW4gZmFjdG9yeVxyXG4gICAqIGZ1bmN0aW9uIHdpbGwgYmUgZmlyZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgdHdlZW4gaW50ZXJwb2xhdGlvbiByYW5nZSFcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgaW50ZXJydXB0OiBGdW5jdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbiAgLyoqXHJcbiAgICogd2lsbCBiZSB0cmlnZ2VyZCB0byBhbmltYXRlIGNoYXJ0IGNoYW5nZXMuXHJcbiAgICogaW1wb3J0YW50ISB0aGlzIG1ldGhvZCBtdXNzdCBiZSBjYWxsZWQgd2l0aGluIGEgc2V0VGltZW91dCBmdW5jdGlvbiBiZWNhdXNlIG9mIGFuZ3VsYXJzIFxyXG4gICAqIHJlbmRlcmluZyBjeWNsZS5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYW5pbWF0ZUNoYW5nZXMoKTogdm9pZCB7XHJcbiAgICAvLyBnZXQgc3ZnIGVsZW1lbnQgcmVmZXJlbmNlXHJcbiAgICBjb25zdCBzdmcgPSAodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJykgYXMgU1ZHRWxlbWVudCk7XHJcbiAgICAvLyByZWZlcmVuY2UgYWxsIHBhdGggZWxlbWVudHMgaW4gc3ZnIGVsZW1lbnRcclxuICAgIGNvbnN0IHBhdGhzID0gZDMuc2VsZWN0KHN2Zykuc2VsZWN0QWxsKCdwYXRoJyk7XHJcbiAgICAvLyBkZWZpbmUgaW50ZXJydXB0aW9uIGZ1bmN0aW9uIHRvIHN0b3AgcnVubmluZyBhbmltYXRpb25zXHJcbiAgICB0aGlzLmludGVycnVwdCA9ICgpID0+IHtcclxuICAgICAgLy8gY2FsbCBwYXRocyBpbnRlcnJ1cHQgbWV0aG9kXHJcbiAgICAgIHBhdGhzLmludGVycnVwdCgpO1xyXG4gICAgICAvLyBkZWxldGUgaW50ZXJ1cHQgZGVmaW5pdGlvblxyXG4gICAgICBkZWxldGUgdGhpcy5pbnRlcnJ1cHQ7XHJcbiAgICB9O1xyXG4gICAgLy8gc3RhcnQgcGF0aCBhbmltYXRpb25cclxuICAgIHBhdGhzXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKHRoaXMuZHVyYXRpb24pXHJcbiAgICAgIC8vIFVzZSBkMyBhdHRyVHdlZW4gdHJhbnNpdGlvbiBtZXRob2Qgd2l0aCBkdW1teSBhdHRyaWJ1dGUuIE1ha2Ugc3VyZSB0aGUgZHVtbXkgYXR0cmlidXRlIGRvZXMgbm90XHJcbiAgICAgIC8vIGV4aXN0cyBhdCBwYXRoIGVsZW1lbnRzIVxyXG4gICAgICAuYXR0clR3ZWVuKCdwaWUtdHdlZW4tZHVtbXknLCAoYXJnMCwgaWR4LCBub2RlTGlzdCkgPT4ge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9ucyB0byBjYWxjdWxhdGUgc3RlcCB2YWx1ZXNcclxuICAgICAgICBjb25zdCBpVmFsdWUgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLmN1ckRhdGFbaWR4XS52YWx1ZSwgdGhpcy5lbmREYXRhW2lkeF0udmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGlTdGFydEFuZ2xlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5jdXJEYXRhW2lkeF0uc3RhcnRBbmdsZSwgdGhpcy5lbmREYXRhW2lkeF0uc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgY29uc3QgaUVuZEFuZ2xlID0gZDMuaW50ZXJwb2xhdGUodGhpcy5jdXJEYXRhW2lkeF0uZW5kQW5nbGUsIHRoaXMuZW5kRGF0YVtpZHhdLmVuZEFuZ2xlKTtcclxuICAgICAgICBjb25zdCBpQ29sb3IgPSBkMy5pbnRlcnBvbGF0ZSh0aGlzLmN1ckRhdGFbaWR4XS5kYXRhLmNvbG9yLCB0aGlzLmVuZERhdGFbaWR4XS5kYXRhLmNvbG9yKTtcclxuICAgICAgICAvLyByZXR1cm4gZmFjdG9yeSBmdW5jdGlvbiBmb3IgYW5pbWF0aW9uIHN0ZXBzXHJcbiAgICAgICAgcmV0dXJuICh0KSA9PiB7XHJcbiAgICAgICAgICAvLyBpbnRlcnBvbGF0ZSB2YWx1ZXMgYnkgZ2l2ZW4gdHJhbnNpdGlvbiB2YWx1ZVxyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhW2lkeF0udmFsdWUgPSBpVmFsdWUodCk7XHJcbiAgICAgICAgICB0aGlzLmN1ckRhdGFbaWR4XS5zdGFydEFuZ2xlID0gaVN0YXJ0QW5nbGUodCk7XHJcbiAgICAgICAgICB0aGlzLmN1ckRhdGFbaWR4XS5lbmRBbmdsZSA9IGlFbmRBbmdsZSh0KTtcclxuICAgICAgICAgIHRoaXMuY3VyRGF0YVtpZHhdLmRhdGEuY29sb3IgPSBpQ29sb3IodCk7XHJcbiAgICAgICAgICAvLyBnZW5lcmF0ZSBuZXcgcGF0aFxyXG4gICAgICAgICAgdGhpcy5jdXJEYXRhW2lkeF0uZGF0YS5wYXRoID0gdGhpcy5wYXRoR2VuZXJhdG9yKHRoaXMuY3VyRGF0YVtpZHhdKTtcclxuICAgICAgICAgIC8vIHJldHVybiBlbXB0eSBzdHJpbmcuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgZm9yIHR5cGVzY3JpcHQgY29tcGlsZXIuIE5vdGhpbmcgc2hvdWxkIGJlIGNoYW5nZWQgaGVyZS5cclxuICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICB9KVxyXG4gICAgICAvLyB3aGVuIHRyYW5zaXRpb24gaXMgY29tcGxldGVcclxuICAgICAgLm9uKCdlbmQnLCAoYXJnMCwgaWR4LCBub2RlTGlzdCkgPT4ge1xyXG4gICAgICAgIC8vIHdoZW4gdHJhbnNpdGlvbiBpcyBjb21wbGV0ZSBmb3IgdGhlIGxhc3QgaXRlbVxyXG4gICAgICAgIGlmKGlkeD09PW5vZGVMaXN0Lmxlbmd0aC0xKXtcclxuICAgICAgICAgIC8vIHJlbW92ZSBhcyBkZWxldGVkIG1hcmtlZCBlbnRyaWVzXHJcbiAgICAgICAgICB0aGlzLmNsZWFuU3RhdGVJdGVtcygpO1xyXG4gICAgICAgICAgLy8gRGVsZXRlIGludGVydXB0IGRlZmluaXRpb24sIGJlY2F1c2UgZXZlcnl0aGluZyBoYXMgZmluaXNoZWQgYW5kIG5vdGhpbmcgY2FuIGJlIGludGVycnVwdGVkLlxyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJydXB0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdHJhbnNpdGlvbiBlbmRzIHRvIHJlbW92ZSBlbnRyaWVzIGluIGN1ckRhdGEgYW5kIGVuZERhdGEgd2hpY2ggYXJlIG1hcmtlZFxyXG4gICAqIGFzIGRlbGV0ZWQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNsZWFuU3RhdGVJdGVtcygpOiB2b2lkIHtcclxuICAgIC8vIGNsZWFuIGN1cnJlbnQgc3RhdGUgYXJyYXlcclxuICAgIGZvcihsZXQgaT10aGlzLmN1ckRhdGEubGVuZ3RoLTE7IGk+PTA7IC0taSl7XHJcbiAgICAgIGlmKHRoaXMuY3VyRGF0YVtpXS5kYXRhLmRlbGV0ZWQ9PT10cnVlKXtcclxuICAgICAgICB0aGlzLmN1ckRhdGEuc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjbGVhbiBlbmQgc3RhdGUgYXJyYXlcclxuICAgIGZvcihsZXQgaT10aGlzLmVuZERhdGEubGVuZ3RoLTE7IGk+PTA7IC0taSl7XHJcbiAgICAgIGlmKHRoaXMuZW5kRGF0YVtpXS5kYXRhLmRlbGV0ZWQ9PT10cnVlKXtcclxuICAgICAgICB0aGlzLmVuZERhdGEuc3BsaWNlKGksMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBhbGwgaXRlbXMgaGF2ZSBhc3NpZ25lZCBjb2xvciB2YWx1ZXMgYW5kIGlmIG5lY2Vzc2FyeSBjb21wbGV0ZXMgY29sb3JzIGluIGdpdmVuIGRhdGEgYXJyYXkuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGluaXRDb2xvcnMoKTogdm9pZCB7XHJcbiAgICAvLyBsb29wIGFsbCBlbnRyaWVzXHJcbiAgICB0aGlzLmRhdGEuZm9yRWFjaCggKGl0ZW0pID0+IHtcclxuICAgICAgLy8gaWYgbm8gY29sb3IgaXMgYXNzaWduZWRcclxuICAgICAgaWYoIWl0ZW0uY29sb3Ipe1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIHJhbmRvbSBjb2xvciBmb3IgaXRlbVxyXG4gICAgICAgIGl0ZW0uY29sb3IgPSB0aGlzLmdlbmVyYXRlUmFuZG9tQ29sb3IoaXRlbS52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbWF4aW1hbCBhbmdsZSBvZiBjdXJyZW50IHN0YXRlIGl0ZW1zLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRNYXhBbmdsZSgpOiBudW1iZXIge1xyXG4gICAgbGV0IG1heEFuZ2xlID0gMDtcclxuICAgIHRoaXMuY3VyRGF0YS5mb3JFYWNoKCAoY3VySXRlbSkgPT4geyBcclxuICAgICAgaWYoY3VySXRlbS5lbmRBbmdsZSA+IG1heEFuZ2xlKXtcclxuICAgICAgICBtYXhBbmdsZSA9IGN1ckl0ZW0uZW5kQW5nbGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1heEFuZ2xlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYW5nbGVzIGZvciBjdXJyZW50IGFuZCBlbmQgc3RhdGUgaXRlbXMuXHJcbiAgICogQHBhcmFtIG1heEFuZ2xlIGxhc3QgbWF4aW1hbCBhbmdsZSBpbiBjdXJyZW50IHN0YXRlIHRvIGF2b2lkIFwianVtcGluZ1wiIHRyYW5zaXRpb25zXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNhbGN1bGF0ZUFuZ2xlcyhtYXhBbmdsZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVzIGZvciBjdXJyZW50IHN0YXRlIGl0ZW1zXHJcbiAgICB7XHJcbiAgICAgIC8vIGNhbGN1bGF0ZSBzdW0gb2YgdmFsdWVzXHJcbiAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5jdXJEYXRhLnJlZHVjZSgocCwgYykgPT4gcCArIGMudmFsdWUsIDApO1xyXG4gICAgICAvLyBsb29wIGl0ZW1zIGFuZCBjYWxjdWxhdGUgc3RhcnQgYW5kIGVuZCBhbmdsZXMsIGluaXRpYWxpemUgcmVuZGVyaW5nXHJcbiAgICAgIGxldCBsYXN0QW5nbGUgPSAwO1xyXG4gICAgICB0aGlzLmN1ckRhdGEuZm9yRWFjaCggKGl0ZW0sIGlkeCkgPT4ge1xyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhbmdsZXMgYnkgbGFzdCB1c2VkIG1heGltYWwgYW5nbGUuIHdpdGhvdXQgZGF0YSAodG90YWw9MCkgc2ltdWxhdGUgMCB2YWx1ZXMsIHNvIGRyYXcgaXRlbXMgaW4gY2xvY2t3aXNlIGRpcmVjdGlvbi5cclxuICAgICAgICBjb25zdCBuZXh0QW5nbGUgPSBsYXN0QW5nbGUgKyAoKG1heEFuZ2xlKSAvICgodG90YWw9PT0wKT8xOnRvdGFsKSkgKiBpdGVtLnZhbHVlO1xyXG4gICAgICAgIGl0ZW0uc3RhcnRBbmdsZSA9IGxhc3RBbmdsZTtcclxuICAgICAgICBpdGVtLmVuZEFuZ2xlID0gbmV4dEFuZ2xlO1xyXG4gICAgICAgIGl0ZW0uaW5kZXggPSBpZHg7XHJcbiAgICAgICAgaXRlbS5kYXRhLnBhdGggPSB0aGlzLnBhdGhHZW5lcmF0b3IoaXRlbSk7XHJcbiAgICAgICAgbGFzdEFuZ2xlID0gbmV4dEFuZ2xlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGNhbGN1bGF0ZSBhbmdsZXMgZm9yIGVuZCBzdGF0ZSBpdGVtc1xyXG4gICAge1xyXG4gICAgICAvLyBjYWxjdWxhdGUgc3VtIG9mIHZhbHVlc1xyXG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuZW5kRGF0YS5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjLnZhbHVlLCAwKTtcclxuICAgICAgLy8gbG9vcCBpdGVtcyBhbmQgY2FsY3VsYXRlIHN0YXJ0IGFuZCBlbmQgYW5nbGVzLCBpbml0aWFsaXplIHJlbmRlcmluZ1xyXG4gICAgICBsZXQgbGFzdEFuZ2xlID0gMDtcclxuICAgICAgdGhpcy5lbmREYXRhLmZvckVhY2goIChpdGVtLCBpZHgpID0+IHtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgYW5nbGVzIHdpdGggY2lyY3VtZmVyZW5jZS4gd2l0aG91dCBkYXRhICh0b3RhbD0wKSBzaW11bGF0ZSAwIHZhbHVlcywgc28gZHJhdyBpdGVtcyBpbiBhbnRpLWNsb2Nrd2lzZSBkaXJlY3Rpb24uXHJcbiAgICAgICAgY29uc3QgbmV4dEFuZ2xlID0gbGFzdEFuZ2xlICsgKCgyICogTWF0aC5QSSkgLyAoKHRvdGFsPT09MCk/MTp0b3RhbCkpICogaXRlbS52YWx1ZTtcclxuICAgICAgICBpdGVtLnN0YXJ0QW5nbGUgPSBsYXN0QW5nbGU7XHJcbiAgICAgICAgaXRlbS5lbmRBbmdsZSA9IG5leHRBbmdsZTtcclxuICAgICAgICBpdGVtLmluZGV4ID0gaWR4O1xyXG4gICAgICAgIGl0ZW0uZGF0YS5wYXRoID0gdGhpcy5wYXRoR2VuZXJhdG9yKGl0ZW0pO1xyXG4gICAgICAgIGxhc3RBbmdsZSA9IG5leHRBbmdsZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqIHJlZmVyZW5jZSB0byB0b29sdGlwIGRpdiBlbGVtZW50ICovXHJcbiAgcHJpdmF0ZSB0b29sdGlwOiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgLyoqXHJcbiAgICogZmlyZWQgd2hlbiBtb3VzZSBlbnRlcnMgYSBwaWUgY2hhcnQgcGF0aCBlbGVtZW50IGFuZCBzaG93cyB0b29sdGlwXHJcbiAgICogQHBhcmFtIGV2ZW50IFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdmVyUGF0aChldmVudDogTW91c2VFdmVudCl7XHJcbiAgICAvLyBnZXQgdG9vbHRpcC10ZXh0IG9mIHBhdGggZWxlbWVudFxyXG4gICAgY29uc3QgdHh0ID0gKGV2ZW50LnRhcmdldCBhcyBTVkdQYXRoRWxlbWVudCkuZ2V0QXR0cmlidXRlKCd0b29sdGlwJyk7XHJcbiAgICAvLyBzaG93IHRvb2x0aXAgYW5kIGFzc2lnbiB0ZXh0XHJcbiAgICBkMy5zZWxlY3QodGhpcy50b29sdGlwKVxyXG4gICAgICAuaHRtbCh0eHQpXHJcbiAgICAgIC5zdHlsZSgnZGlzcGxheScsICdibG9jaycpXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKDI1MClcclxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgLy8gZ2V0IGluZGV4XHJcbiAgICBjb25zdCBpZHggPSBwYXJzZUludCgoZXZlbnQudGFyZ2V0IGFzIFNWR1BhdGhFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2lkeCcpLDEwKTtcclxuICAgIC8vIGdldCBjYXB0aW9uIG9mIGVsZW1lbnRcclxuICAgIGNvbnN0IGNhcHRpb24gPSB0aGlzLmN1ckRhdGFbaWR4XS5kYXRhLmNhcHRpb247XHJcbiAgICAvLyBnZXQgb3JpZ2luYWwgZGF0YSBieSBjYXB0aW9uXHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5kYXRhLmZpbHRlciggKGQpID0+IGQuY2FwdGlvbiA9PT0gY2FwdGlvbilbMF07XHJcbiAgICAvLyBpZiBkYXRhIGZvdW5kIHRoZW4gZW1pdCBjaGFydCBjbGljayBldmVudFxyXG4gICAgaWYoaXRlbSl7XHJcbiAgICAgIHRoaXMuY2hhcnRIb3Zlci5lbWl0KGl0ZW0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGZpcmVkIHdoZW4gbW91c2UgbW92ZXMgb3ZlciBhIHBpZSBjaGFydCBwYXRoIGVsZW1lbnQgYW5kIGFkanVzdHMgdG9vbHRpcFxyXG4gICAqIEBwYXJhbSBldmVudCBcclxuICAgKi9cclxuICBwdWJsaWMgbW92ZVBhdGgoZXZlbnQ6IE1vdXNlRXZlbnQpe1xyXG4gICAgLy8gYWdncmVnYXRlIHNjcm9sbCBwb3NpdGlvbnMsIGJlY2F1c2UgZXZlbnQucGFnZSogcHJvcGVydGllcyBhcmUgcmVsYXRpdmUgdG8gdG9wIGxlZnQgY29ybmVyIG9mIGRvY3VtZW50XHJcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcbiAgICBsZXQgZWxlbWVudCA9ICh0aGlzLnRvb2x0aXAucGFyZW50RWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICB3aGlsZShlbGVtZW50KXtcclxuICAgICAgb2Zmc2V0WCArPSBlbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgICAgIG9mZnNldFkgKz0gZWxlbWVudC5zY3JvbGxUb3A7XHJcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBhZGp1c3QgdG9vbHRpcFxyXG4gICAgZDMuc2VsZWN0KHRoaXMudG9vbHRpcClcclxuICAgICAgLnN0eWxlKCd0b3AnLCAoZXZlbnQucGFnZVkgLSBvZmZzZXRZICsgMTApKydweCcpXHJcbiAgICAgIC5zdHlsZSgnbGVmdCcsIChldmVudC5wYWdlWCAtIG9mZnNldFggKyAxMCkrJ3B4Jyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogZmlyZWQgd2hlbiBtb3VzZSBsZWF2ZXMgYSBwaWUgY2hhcnQgcGF0aCBlbGVtZW50IGFuZCBoaWRlcyB0b29sdGlwXHJcbiAgICogQHBhcmFtIGV2ZW50IFxyXG4gICAqL1xyXG4gIHB1YmxpYyBvdXRQYXRoKGV2ZW50OiBNb3VzZUV2ZW50KXtcclxuICAgIC8vIGhpZGUgdG9vbHRpcFxyXG4gICAgZDMuc2VsZWN0KHRoaXMudG9vbHRpcClcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24oMjUwKVxyXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLDApXHJcbiAgICAgIC5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLnRvb2x0aXApLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKVxyXG4gICAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBmaXJlZCB3aGVuIHVzZXIgY2xpY2tzIG9uIGEgcGllIGNoYXJ0IHBhdGggZWxlbWVudFxyXG4gICAqIEBwYXJhbSBldmVudCBcclxuICAgKi9cclxuICBwdWJsaWMgY2xpY2tQYXRoKGV2ZW50OiBNb3VzZUV2ZW50KXtcclxuICAgIC8vIGdldCBpbmRleFxyXG4gICAgY29uc3QgaWR4ID0gcGFyc2VJbnQoKGV2ZW50LnRhcmdldCBhcyBTVkdQYXRoRWxlbWVudCkuZ2V0QXR0cmlidXRlKCdpZHgnKSwxMCk7XHJcbiAgICAvLyBnZXQgY2FwdGlvbiBvZiBlbGVtZW50XHJcbiAgICBjb25zdCBjYXB0aW9uID0gdGhpcy5jdXJEYXRhW2lkeF0uZGF0YS5jYXB0aW9uO1xyXG4gICAgLy8gZ2V0IG9yaWdpbmFsIGRhdGEgYnkgY2FwdGlvblxyXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuZGF0YS5maWx0ZXIoIChkKSA9PiBkLmNhcHRpb24gPT09IGNhcHRpb24pWzBdO1xyXG4gICAgLy8gaWYgZGF0YSBmb3VuZCB0aGVuIGVtaXQgY2hhcnQgY2xpY2sgZXZlbnRcclxuICAgIGlmKGl0ZW0pe1xyXG4gICAgICB0aGlzLmNoYXJ0Q2xpY2suZW1pdChpdGVtKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBtYWluIHJlbmRlcmluZyBmdW5jdGlvblxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCByZW5kZXIoKTogdm9pZHtcclxuICAgIC8vIGludGVycnVwdCBwb3NzaWJsZSBydW5uaW5nIGFuaW1hdGlvbnNcclxuICAgIGlmKHRoaXMuaW50ZXJydXB0KSB0aGlzLmludGVycnVwdCgpO1xyXG4gICAgLy8gaW5pdGlhbGl6ZSBjaGFydCBjb2xvcnNcclxuICAgIHRoaXMuaW5pdENvbG9ycygpO1xyXG4gICAgLy8gY2FsY3VsYXRlIHJhZGl1c1xyXG4gICAgdGhpcy5yYWRpdXMgPSBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyO1xyXG4gICAgLy8gY2FsY3VsYXRlIG1pZGRsZSBvZiBjaGFydFxyXG4gICAgdGhpcy5jZW50ZXIgPSBgdHJhbnNsYXRlKCR7dGhpcy53aWR0aCAvIDJ9LCAke3RoaXMuaGVpZ2h0IC8gMn0pYDtcclxuICAgIC8vIGNyZWF0ZSBwYXRoIGdlbmVyYXRvclxyXG4gICAgdGhpcy5wYXRoR2VuZXJhdG9yID0gZDMuYXJjKCkub3V0ZXJSYWRpdXModGhpcy5yYWRpdXMtdGhpcy5vdXRlclNwYWNpbmcpLmlubmVyUmFkaXVzKHRoaXMuaW5uZXJTcGFjaW5nKTtcclxuICAgIC8vIGdldCBjdXJyZW50IG1heGltYWwgYW5nbGUsIG5lY2Vzc2FyeSB0byBhdm9pZCBcImp1bXBpbmdcIiB0cmFuc2l0aW9uc1xyXG4gICAgY29uc3QgbWF4QW5nbGUgPSB0aGlzLmdldE1heEFuZ2xlKCk7XHJcbiAgICAvLyBjaGVjayBkYXRhIGFycmF5IGZvciBkZWxldGVkIGVudHJpZXMgYW5kIGFzc2lnbiB0cmFuc2l0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgIHRoaXMuZGV0ZWN0RGVsZXRlZEVudHJpZXMoKTtcclxuICAgIC8vIGNoZWNrIGRhdGEgYXJyYXkgZm9yIGluc2VydGVkIGVudHJpZXMgYW5kIGFzc2lnbiB0cmFuc2l0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgIHRoaXMuZGV0ZWN0SW5zZXJ0ZWRFbnRyaWVzKCk7XHJcbiAgICAvLyBjaGVjayBkYXRhIGFycmF5IGZvciBtb3ZlZCBlbnRyaWVzIGFuZCBhc3NpZ24gdHJhbnNpdGlvbiBjb25maWd1cmF0aW9uXHJcbiAgICB0aGlzLmRldGVjdE1vdmVkRW50cmllcygpO1xyXG4gICAgLy8gc3luY2hyb25pemUgZGF0YSBlbnRyaWVzIHdpdGggY3VycmVudCBhbmQgZW5kIHN0YXRlIGVudHJpZXNcclxuICAgIHRoaXMuc3luY0l0ZW1zKCk7XHJcbiAgICAvLyBjYWxjdWxhdGUgYW5nbGVzIGZvciBjdXJyZW50IGFuZCBlbmQgc3RhdGUgZW50cmllc1xyXG4gICAgdGhpcy5jYWxjdWxhdGVBbmdsZXMobWF4QW5nbGUpO1xyXG4gICAgLy8gaW1wb3J0YW50ISB1c2Ugc2V0VGltZW91dCBiZWNhdXNlIGFuZ3VsYXIgZmlyc3QgbXVzdCBleGVjIGNoYW5nZSBkZXRlY3Rpb25cclxuICAgIHNldFRpbWVvdXQoICgpID0+IHtcclxuICAgICAgLy8gc3RhcnQgY2hhbmdlIGFuaW1hdGlvbnNcclxuICAgICAgdGhpcy5hbmltYXRlQ2hhbmdlcygpO1xyXG4gICAgfSwgMCk7XHJcbiAgfTtcclxuXHJcbiAgLypcclxuICBwcml2YXRlIHZlcnNpb24xKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc3VtID0gdGhpcy5kYXRhLnJlZHVjZSgocCwgYykgPT4gcCArIGMudmFsdWUsIDApO1xyXG4gICAgbGV0IGxhc3RBbmdsZSA9IDA7XHJcbiAgICB0aGlzLmRhdGEuZm9yRWFjaChkID0+IHtcclxuICAgICAgY29uc3QgbmV3QW5nbGUgPSBsYXN0QW5nbGUgKyAoKDIgKiBNYXRoLlBJKSAvIHN1bSkgKiBkLnZhbHVlO1xyXG4gICAgICBjb25zdCBjb250ZXh0ID0gcGF0aCgpO1xyXG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcclxuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5yYWRpdXMsIGxhc3RBbmdsZSwgbmV3QW5nbGUsIGZhbHNlKTtcclxuICAgICAgZC5wYXRoID0gY29udGV4dC50b1N0cmluZygpO1xyXG4gICAgICBjb25zb2xlLmxvZyhkLnBhdGgpO1xyXG4gICAgICBsYXN0QW5nbGUgPSBuZXdBbmdsZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAqL1xyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFBpZUNoYXJ0Q29tcG9uZW50IH0gZnJvbSAnLi9waWUtY2hhcnQuY29tcG9uZW50JztcclxuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiBbQnJvd3Nlck1vZHVsZV0sXHJcbiAgZGVjbGFyYXRpb25zOiBbUGllQ2hhcnRDb21wb25lbnRdLFxyXG4gIGV4cG9ydHM6IFtQaWVDaGFydENvbXBvbmVudF1cclxufSlcclxuZXhwb3J0IGNsYXNzIFBpZUNoYXJ0TW9kdWxlIHt9XHJcbiJdLCJuYW1lcyI6WyJJbmplY3RhYmxlIiwiRXZlbnRFbWl0dGVyIiwiZDMuc2VsZWN0IiwiZDMuaW50ZXJwb2xhdGUiLCJkMy5hcmMiLCJDb21wb25lbnQiLCJFbGVtZW50UmVmIiwiSW5wdXQiLCJPdXRwdXQiLCJOZ01vZHVsZSIsIkJyb3dzZXJNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtRQU9FO1NBQWlCOztvQkFMbEJBLGFBQVUsU0FBQzt3QkFDVixVQUFVLEVBQUUsTUFBTTtxQkFDbkI7Ozs7OzhCQUpEOzs7Ozs7O0FDQUE7Ozs7O1FBa0ZFLDJCQUNVO1lBQUEsWUFBTyxHQUFQLE9BQU87Ozs7d0JBNUNvQixFQUFFOzs7O3lCQUV0QixHQUFHOzs7OzBCQUVGLEdBQUc7Ozs7NEJBRUQsSUFBSTs7OztnQ0FFQSxDQUFDOzs7O2dDQUVELENBQUM7Ozs7OEJBRTBCLElBQUlDLGVBQVksRUFBRTs7Ozs4QkFFbEIsSUFBSUEsZUFBWSxFQUFFOzs7OzJCQU90QyxFQUFFOzs7OzJCQUVELEVBQUU7Ozs7NEJBSU0sRUFBRTs7Ozs7Ozs2QkFvUFYsU0FBUztTQWxPckM7Ozs7Ozs7Ozs7Ozs7OztRQVZNLG9DQUFROzs7Ozs7OztZQUFsQixVQUFzQixDQUFJO2dCQUN4QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RDOzs7O1FBVUQsb0NBQVE7OztZQUFSO2dCQUNFLElBQUksQ0FBQyxPQUFPLHFCQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyx1QkFBdUIsQ0FBbUIsQ0FBQSxDQUFDO2FBQ3BHOzs7Ozs7Ozs7Ozs7UUFPRCx1Q0FBVzs7Ozs7O1lBQVgsVUFBWSxPQUFzQjs7Z0JBRWhD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Q0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUM7d0JBRWxFOzs0QkFFRSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOzs0QkFFM0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs0QkFDM0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO3lCQUNsQzt3QkFFRDs0QkFDRSxxQkFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7NEJBQzdDLHFCQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUN2RCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO3lCQUNyQzt3QkFFRDs0QkFDRSxxQkFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7NEJBQzdDLHFCQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFDaEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzt5QkFDckM7O3dCQUVELEVBQUUsUUFBUSxDQUFDO3FCQUNaO29CQUNELEVBQUUsUUFBUSxDQUFDO2lCQUNaO2FBQ0Y7Ozs7Ozs7O1FBS1MscUNB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