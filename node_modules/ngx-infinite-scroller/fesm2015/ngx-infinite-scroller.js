import { Directive, ElementRef, Input, Output, EventEmitter, Renderer2, NgModule } from '@angular/core';
import { Subject, zip, fromEvent } from 'rxjs';
import isNumber from 'is-number';
import { filter, tap, map, pairwise, takeWhile, skipWhile, debounceTime } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DirectiveStateService {
    /**
     * @return {?}
     */
    get scrollTop() {
        return this._el.nativeElement.scrollTop;
    }
    /**
     * @return {?}
     */
    get scrollHeight() {
        return this._el.nativeElement.scrollHeight;
    }
    /**
     * @return {?}
     */
    get clientHeight() {
        return this._el.nativeElement.clientHeight;
    }
    /**
     * @return {?}
     */
    get initMode() {
        return this._initMode;
    }
    /**
     * @param {?} initMode
     * @return {?}
     */
    set initMode(initMode) {
        this._initMode = initMode;
    }
    /**
     * @return {?}
     */
    get scrollStreamActive() {
        return this._scrollStreamActive;
    }
    /**
     * @param {?} active
     * @return {?}
     */
    set scrollStreamActive(active) {
        this._scrollStreamActive = active;
    }
    /**
     * @return {?}
     */
    get previousScrollPositionpUpdated() {
        return this._previousScrollPositionpUpdated;
    }
    /**
     * @param {?} previousScrollPositionpUpdated
     * @return {?}
     */
    set previousScrollPositionpUpdated(previousScrollPositionpUpdated) {
        this._previousScrollPositionpUpdated = previousScrollPositionpUpdated;
    }
    /**
     * @return {?}
     */
    get previousScrollTop() {
        return this._previousScrollTop;
    }
    /**
     * @return {?}
     */
    get previousScrollHeight() {
        return this._previousScrollHeight;
    }
    /**
     * @param {?} params
     * @return {?}
     */
    setup(params) {
        this._el = params.el;
        this._initMode = params.initMode;
        this._scrollStreamActive = params.scrollStreamActive;
        this._previousScrollPositionpUpdated = params.previousScrollPositionpUpdated;
        this.updatePreviousScrollTop();
        this.updatePreviousScrollHeight();
    }
    /**
     * @return {?}
     */
    updatePreviousScrollTop() {
        this._previousScrollTop = this._el.nativeElement.scrollTop;
    }
    /**
     * @return {?}
     */
    updatePreviousScrollHeight() {
        this._previousScrollHeight = this._el.nativeElement.scrollHeight;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const InitialScrollPosition = {
    DEFAULT: 'DEFAULT',
    TOP: 'TOP',
    MIDDLE: 'MIDDLE',
    BOTTOM: 'BOTTOM',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class DirectiveContext {
    constructor() { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class StrategyBase {
    /**
     * @param {?} directive
     * @param {?} state
     */
    constructor(directive, state) {
        this.directive = directive;
        this.state = state;
    }
    /**
     * @protected
     * @param {?} prevPos
     * @param {?} currentPos
     * @return {?}
     */
    wasScrolledDown(prevPos, currentPos) {
        return prevPos.scrollTop < currentPos.scrollTop;
    }
    /**
     * @protected
     * @param {?} prevPos
     * @param {?} currentPos
     * @return {?}
     */
    wasScrolledUp(prevPos, currentPos) {
        return !this.wasScrolledDown(prevPos, currentPos);
    }
    /**
     * @protected
     * @param {?} pos
     * @param {?} scrollPositionTrigger
     * @return {?}
     */
    isScrollDownEnough(pos, scrollPositionTrigger) {
        return ((pos.scrollTop + pos.clientHeight) / pos.scrollHeight) > (scrollPositionTrigger / 100);
    }
    /**
     * @protected
     * @param {?} pos
     * @param {?} scrollPositionTrigger
     * @return {?}
     */
    isScrollUpEnough(pos, scrollPositionTrigger) {
        return (pos.scrollTop / pos.scrollHeight) < (scrollPositionTrigger / 100);
    }
    /**
     * @protected
     * @param {?} defaultScrollPosition
     * @return {?}
     */
    getInitialScrollPositionValue(defaultScrollPosition) {
        const { initialScrollPosition } = this.directive;
        if (isNumber(initialScrollPosition)) {
            return Number(initialScrollPosition);
        }
        /** @type {?} */
        const initialScrollPositions = this.getInitialScrollPositions();
        if (initialScrollPosition === InitialScrollPosition.DEFAULT) {
            return initialScrollPositions[defaultScrollPosition];
        }
        return initialScrollPositions[initialScrollPosition];
    }
    /**
     * @private
     * @return {?}
     */
    getInitialScrollPositions() {
        const { scrollHeight, clientHeight } = this.state;
        return {
            [InitialScrollPosition.TOP]: 0,
            [InitialScrollPosition.MIDDLE]: scrollHeight / 2 - clientHeight / 2,
            [InitialScrollPosition.BOTTOM]: scrollHeight,
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollingToTop extends StrategyBase {
    /**
     * @param {?} directive
     * @param {?} state
     */
    constructor(directive, state) {
        super(directive, state);
    }
    /**
     * @param {?} scrollPairChanged
     * @return {?}
     */
    scrollDirectionChanged(scrollPairChanged) {
        return scrollPairChanged.pipe(filter((scrollPositions) => {
            return super.wasScrolledUp(scrollPositions[0], scrollPositions[1]);
        }));
    }
    /**
     * @param {?} scrollDirectionChanged
     * @return {?}
     */
    scrollRequestZoneChanged(scrollDirectionChanged) {
        return scrollDirectionChanged.pipe(filter((scrollPositions) => {
            return super.isScrollUpEnough(scrollPositions[1], this.directive.scrollUpPercentilePositionTrigger);
        }));
    }
    /**
     * @return {?}
     */
    askForUpdate() {
        this.directive.onScrollUp.next();
    }
    /**
     * @return {?}
     */
    setInitialScrollPosition() {
        /** @type {?} */
        const initialScrollPositionValue = super.getInitialScrollPositionValue(InitialScrollPosition.BOTTOM);
        this.directive.scrollTo(initialScrollPositionValue);
    }
    /**
     * @return {?}
     */
    setPreviousScrollPosition() {
        /** @type {?} */
        const prevScrollPosition = this.state.previousScrollTop +
            (this.state.scrollHeight - this.state.previousScrollHeight);
        this.directive.scrollTo(prevScrollPosition);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollingToBottom extends StrategyBase {
    /**
     * @param {?} directive
     * @param {?} state
     */
    constructor(directive, state) {
        super(directive, state);
    }
    /**
     * @param {?} scrollPairChanged
     * @return {?}
     */
    scrollDirectionChanged(scrollPairChanged) {
        return scrollPairChanged.pipe(filter((scrollPositions) => {
            return super.wasScrolledDown(scrollPositions[0], scrollPositions[1]);
        }));
    }
    /**
     * @param {?} scrollDirectionChanged
     * @return {?}
     */
    scrollRequestZoneChanged(scrollDirectionChanged) {
        return scrollDirectionChanged.pipe(filter((scrollPositions) => {
            return super.isScrollDownEnough(scrollPositions[1], this.directive.scrollDownPercentilePositionTrigger);
        }));
    }
    /**
     * @return {?}
     */
    askForUpdate() {
        this.directive.onScrollDown.next();
    }
    /**
     * @return {?}
     */
    setInitialScrollPosition() {
        /** @type {?} */
        const initialScrollPositionValue = super.getInitialScrollPositionValue(InitialScrollPosition.TOP);
        this.directive.scrollTo(initialScrollPositionValue);
    }
    /**
     * @return {?}
     */
    setPreviousScrollPosition() {
        /** @type {?} */
        const prevScrollPosition = this.state.previousScrollTop;
        this.directive.scrollTo(prevScrollPosition);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollingToBoth extends StrategyBase {
    /**
     * @param {?} directive
     * @param {?} state
     */
    constructor(directive, state) {
        super(directive, state);
    }
    /**
     * @param {?} scrollPairChanged
     * @return {?}
     */
    scrollDirectionChanged(scrollPairChanged) {
        return scrollPairChanged;
    }
    /**
     * @param {?} scrollDirectionChanged
     * @return {?}
     */
    scrollRequestZoneChanged(scrollDirectionChanged) {
        return scrollDirectionChanged.pipe(filter((scrollPositions) => {
            return (super.isScrollUpEnough(scrollPositions[1], this.directive.scrollUpPercentilePositionTrigger) || super.isScrollDownEnough(scrollPositions[1], this.directive.scrollDownPercentilePositionTrigger));
        }), tap((scrollPositions) => {
            this.scrolledUp = super.wasScrolledUp(scrollPositions[0], scrollPositions[1]);
        }));
    }
    /**
     * @return {?}
     */
    askForUpdate() {
        if (this.scrolledUp) {
            this.directive.onScrollUp.next();
        }
        else {
            this.directive.onScrollDown.next();
        }
    }
    /**
     * @return {?}
     */
    setInitialScrollPosition() {
        /** @type {?} */
        const initialScrollPositionValue = super.getInitialScrollPositionValue(InitialScrollPosition.MIDDLE);
        this.directive.scrollTo(initialScrollPositionValue);
    }
    /**
     * @return {?}
     */
    setPreviousScrollPosition() {
        /** @type {?} */
        let prevScrollPosition;
        if (this.scrolledUp) {
            prevScrollPosition = this.state.previousScrollTop +
                (this.state.scrollHeight - this.state.previousScrollHeight);
        }
        else {
            prevScrollPosition = this.state.previousScrollTop;
        }
        this.directive.scrollTo(prevScrollPosition);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollHeightListener {
    /**
     * @param {?} directive
     * @param {?} state
     */
    constructor(directive, state) {
        this.directive = directive;
        this.state = state;
        this.DEFAULT_REQUEST_TIMEOUT = 30000;
    }
    /**
     * @return {?}
     */
    start() {
        this.listener = window.requestAnimationFrame(this.listen.bind(this));
        if (!this.httpRequestTimeout) {
            this.httpRequestTimeout = setTimeout(() => {
                this.stopIfRequestTimeout();
            }, this.DEFAULT_REQUEST_TIMEOUT);
        }
    }
    /**
     * @return {?}
     */
    stop() {
        window.cancelAnimationFrame(this.listener);
        clearTimeout(this.httpRequestTimeout);
        this.httpRequestTimeout = null;
    }
    /**
     * @private
     * @return {?}
     */
    listen() {
        if (this.state.previousScrollHeight !== this.state.scrollHeight) {
            this.stop();
            this.directive.onScrollbarHeightChanged();
        }
        else {
            this.start();
        }
    }
    /**
     * @private
     * @return {?}
     */
    stopIfRequestTimeout() {
        if (!this.state.previousScrollPositionpUpdated) {
            this.stop();
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxInfiniteScrollerDirective extends DirectiveContext {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} state
     */
    constructor(el, renderer, state) {
        super();
        this.el = el;
        this.renderer = renderer;
        this.state = state;
        this.strategy = 'scrollingToBottom';
        this.initialScrollPosition = InitialScrollPosition.DEFAULT;
        this.scrollbarAnimationInterval = 100;
        this.scrollDebounceTimeAfterScrollHeightChanged = 50;
        this.scrollDebounceTimeAfterDOMMutationOnInit = 1000;
        this.scrollUpPercentilePositionTrigger = 2;
        this.scrollDownPercentilePositionTrigger = 98;
        this.onScrollUp = new EventEmitter();
        this.onScrollDown = new EventEmitter();
        this.scrollHeightChanged = new Subject();
        this.domMutationEmitter = new Subject();
        this.state.setup({
            el: el,
            initMode: true,
            scrollStreamActive: true,
            previousScrollPositionpUpdated: false
        });
    }
    /**
     * @private
     * @return {?}
     */
    get scrollPairChanged() {
        if (this.scrollChanged) {
            return this.scrollChanged.pipe(takeWhile(() => this.state.scrollStreamActive), map((e) => {
                return (/** @type {?} */ ({
                    scrollHeight: e.target.scrollHeight,
                    scrollTop: e.target.scrollTop,
                    clientHeight: e.target.clientHeight,
                }));
            }), pairwise(), debounceTime(this.scrollbarAnimationInterval));
        }
    }
    /**
     * @private
     * @return {?}
     */
    get scrollDirectionChanged() {
        return this.scrollingStrategy.scrollDirectionChanged(this.scrollPairChanged);
    }
    /**
     * @private
     * @return {?}
     */
    get scrollRequestZoneChanged() {
        return this.scrollingStrategy.scrollRequestZoneChanged(this.scrollDirectionChanged).pipe(tap(() => {
            this.state.updatePreviousScrollTop();
            this.state.updatePreviousScrollHeight();
            this.state.previousScrollPositionpUpdated = false;
            this.scrollHeightListener.start();
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.useStrategy();
        this.useScrollHeightListener();
        this.registerScrollEventHandler();
        this.registerMutationObserver();
        this.registerInitialScrollPostionHandler();
        this.registerPreviousScrollPositionHandler();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.registerScrollSpy();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.domMutationObserver.disconnect();
    }
    /**
     * @param {?} position
     * @return {?}
     */
    scrollTo(position) {
        this.state.scrollStreamActive = false;
        this.renderer.setProperty(this.el.nativeElement, 'scrollTop', position);
        this.state.scrollStreamActive = true;
    }
    /**
     * @return {?}
     */
    onScrollbarHeightChanged() {
        this.scrollHeightChanged.next();
    }
    /**
     * @private
     * @return {?}
     */
    registerScrollEventHandler() {
        this.scrollChanged = fromEvent(this.el.nativeElement, 'scroll');
    }
    /**
     * @private
     * @return {?}
     */
    registerMutationObserver() {
        this.domMutationObserver = new MutationObserver((mutations) => {
            this.domMutationEmitter.next(mutations);
        });
        /** @type {?} */
        const config = { attributes: true, childList: true, characterData: true };
        this.domMutationObserver.observe(this.el.nativeElement, config);
    }
    /**
     * @private
     * @return {?}
     */
    registerInitialScrollPostionHandler() {
        this.domMutationEmitter.pipe(takeWhile(() => this.state.initMode), debounceTime(this.scrollDebounceTimeAfterDOMMutationOnInit)).subscribe(() => {
            this.scrollingStrategy.setInitialScrollPosition();
            this.state.initMode = false;
        });
    }
    /**
     * @private
     * @return {?}
     */
    registerPreviousScrollPositionHandler() {
        zip(this.scrollRequestZoneChanged, this.scrollHeightChanged).pipe(skipWhile(() => this.state.initMode), debounceTime(this.scrollDebounceTimeAfterScrollHeightChanged)).subscribe(() => {
            this.scrollingStrategy.setPreviousScrollPosition();
            this.state.previousScrollPositionpUpdated = true;
        });
    }
    /**
     * @private
     * @return {?}
     */
    registerScrollSpy() {
        this.scrollRequestZoneChanged.subscribe(() => {
            this.scrollingStrategy.askForUpdate();
        });
    }
    /**
     * @private
     * @return {?}
     */
    useStrategy() {
        switch (this.strategy) {
            case 'scrollingToBoth':
                this.scrollingStrategy = new ScrollingToBoth(this, this.state);
                break;
            case 'scrollingToTop':
                this.scrollingStrategy = new ScrollingToTop(this, this.state);
                break;
            case 'scrollingToBottom':
            default:
                this.scrollingStrategy = new ScrollingToBottom(this, this.state);
                break;
        }
    }
    /**
     * @private
     * @return {?}
     */
    useScrollHeightListener() {
        this.scrollHeightListener = new ScrollHeightListener(this, this.state);
    }
}
NgxInfiniteScrollerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxInfiniteScroller]'
            },] }
];
/** @nocollapse */
NgxInfiniteScrollerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DirectiveStateService }
];
NgxInfiniteScrollerDirective.propDecorators = {
    strategy: [{ type: Input }],
    initialScrollPosition: [{ type: Input }],
    scrollbarAnimationInterval: [{ type: Input }],
    scrollDebounceTimeAfterScrollHeightChanged: [{ type: Input }],
    scrollDebounceTimeAfterDOMMutationOnInit: [{ type: Input }],
    scrollUpPercentilePositionTrigger: [{ type: Input }],
    scrollDownPercentilePositionTrigger: [{ type: Input }],
    onScrollUp: [{ type: Output }],
    onScrollDown: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxInfiniteScrollerModule {
}
NgxInfiniteScrollerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NgxInfiniteScrollerDirective
                ],
                imports: [],
                exports: [
                    NgxInfiniteScrollerDirective
                ],
                providers: [
                    DirectiveStateService
                ],
                bootstrap: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxInfiniteScrollerModule, DirectiveContext as ɵb, DirectiveStateService as ɵc, NgxInfiniteScrollerDirective as ɵa };

//# sourceMappingURL=ngx-infinite-scroller.js.map