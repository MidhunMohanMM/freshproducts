/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, HostListener, EventEmitter, Input, Output, } from '@angular/core';
import { Subject } from 'rxjs';
import { debounceTime, takeUntil, filter, map } from 'rxjs/operators';
import * as events from './shared/events';
/**
 * \@example
 * ```html
 * <div
 *   class="foo"
 *   snInfiniteScroll
 *   (scrollEnd)="onScrollEnd()"
 *   [offset]="100"
 *   [debounce]="123"
 *   [disabled]="disabled">
 * </div>
 * ```
 *
 */
var InfiniteScrollDirective = /** @class */ (function () {
    function InfiniteScrollDirective() {
        /**
         * Event that will be triggered when user has scrolled to
         * bottom of the element
         */
        this.scrollEnd = new EventEmitter();
        /**
         * An offset from the bottom of the element to trigger
         * `scrollEnd` event
         */
        this.offset = 0;
        /**
         * Specify debounce duration in ms
         */
        this.debounce = 100;
        /**
         * If true then `scrollEnd` event should NOT be emitted
         */
        this.disabled = false;
        /**
         * Emits a new value on element scroll event
         */
        this.scroll$ = new Subject();
        /**
         * Completes on component destroy lifecycle event
         * used to unsubscribe from infinite observables
         *
         */
        this.ngUnsubscribe$ = new Subject();
    }
    /**
     * Subscribe to `scroll$` observable and emit `scrollEnd` event
     * when element scroll position is at the end of the element
     */
    /**
     * Subscribe to `scroll$` observable and emit `scrollEnd` event
     * when element scroll position is at the end of the element
     * @return {?}
     */
    InfiniteScrollDirective.prototype.ngAfterViewInit = /**
     * Subscribe to `scroll$` observable and emit `scrollEnd` event
     * when element scroll position is at the end of the element
     * @return {?}
     */
    function () {
        var _this = this;
        this.scroll$
            .pipe(takeUntil(this.ngUnsubscribe$), debounceTime(this.debounce), map(function (scroll) {
            /** @type {?} */
            var y = scroll.y + _this.offset;
            return { y: y, height: scroll.height };
        }), filter(function () { return !_this.disabled; }), filter(function (scroll) { return scroll.y >= scroll.height; }))
            .subscribe(function () { return _this.scrollEnd.emit(); });
    };
    /**
     * On element scroll event emit next `scroll$` observable value
     */
    /**
     * On element scroll event emit next `scroll$` observable value
     * @param {?} scrollY
     * @param {?} scrollheight
     * @param {?} offsetHeight
     * @return {?}
     */
    InfiniteScrollDirective.prototype.onScroll = /**
     * On element scroll event emit next `scroll$` observable value
     * @param {?} scrollY
     * @param {?} scrollheight
     * @param {?} offsetHeight
     * @return {?}
     */
    function (scrollY, scrollheight, offsetHeight) {
        /** @type {?} */
        var height = scrollheight;
        /** @type {?} */
        var y = scrollY + offsetHeight;
        this.scroll$.next({ y: y, height: height });
    };
    /**
     * trigger `ngUnsubscribe` complete on
     * component destroy lifecycle hook
     */
    /**
     * trigger `ngUnsubscribe` complete on
     * component destroy lifecycle hook
     * @return {?}
     */
    InfiniteScrollDirective.prototype.ngOnDestroy = /**
     * trigger `ngUnsubscribe` complete on
     * component destroy lifecycle hook
     * @return {?}
     */
    function () {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    };
    InfiniteScrollDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[snInfiniteScroll]',
                },] }
    ];
    InfiniteScrollDirective.propDecorators = {
        scrollEnd: [{ type: Output }],
        offset: [{ type: Input }],
        debounce: [{ type: Input }],
        disabled: [{ type: Input }],
        onScroll: [{ type: HostListener, args: [events.eventScroll, events.eventPathScroll,] }]
    };
    return InfiniteScrollDirective;
}());
export { InfiniteScrollDirective };
if (false) {
    /**
     * Event that will be triggered when user has scrolled to
     * bottom of the element
     * @type {?}
     */
    InfiniteScrollDirective.prototype.scrollEnd;
    /**
     * An offset from the bottom of the element to trigger
     * `scrollEnd` event
     * @type {?}
     */
    InfiniteScrollDirective.prototype.offset;
    /**
     * Specify debounce duration in ms
     * @type {?}
     */
    InfiniteScrollDirective.prototype.debounce;
    /**
     * If true then `scrollEnd` event should NOT be emitted
     * @type {?}
     */
    InfiniteScrollDirective.prototype.disabled;
    /**
     * Emits a new value on element scroll event
     * @type {?}
     */
    InfiniteScrollDirective.prototype.scroll$;
    /**
     * Completes on component destroy lifecycle event
     * used to unsubscribe from infinite observables
     *
     * @type {?}
     * @private
     */
    InfiniteScrollDirective.prototype.ngUnsubscribe$;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0aGlzaXNzb29uL2FuZ3VsYXItaW5maW5pdGUtc2Nyb2xsLyIsInNvdXJjZXMiOlsiYXBwL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUdULFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd0RSxPQUFPLEtBQUssTUFBTSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFnQjFDO0lBQUE7Ozs7O1FBUW1CLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDOzs7OztRQUt0QyxXQUFNLEdBQUcsQ0FBQyxDQUFDOzs7O1FBSVgsYUFBUSxHQUFHLEdBQUcsQ0FBQzs7OztRQUlmLGFBQVEsR0FBRyxLQUFLLENBQUM7Ozs7UUFJMUIsWUFBTyxHQUFvQixJQUFJLE9BQU8sRUFBVSxDQUFDOzs7Ozs7UUFNaEQsbUJBQWMsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0lBd0MvQyxDQUFDO0lBdkNDOzs7T0FHRzs7Ozs7O0lBQ0ksaURBQWU7Ozs7O0lBQXRCO1FBQUEsaUJBYUM7UUFaQyxJQUFJLENBQUMsT0FBTzthQUNULElBQUksQ0FDSCxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUM5QixZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUMzQixHQUFHLENBQUMsVUFBQSxNQUFNOztnQkFDRixDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFJLENBQUMsTUFBTTtZQUNoQyxPQUFPLEVBQUUsQ0FBQyxHQUFBLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUN0QyxDQUFDLENBQUMsRUFDRixNQUFNLENBQUMsY0FBTSxPQUFBLENBQUMsS0FBSSxDQUFDLFFBQVEsRUFBZCxDQUFjLENBQUMsRUFDNUIsTUFBTSxDQUFDLFVBQUEsTUFBTSxJQUFJLE9BQUEsTUFBTSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUF6QixDQUF5QixDQUFDLENBQzVDO2FBQ0EsU0FBUyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxFQUFyQixDQUFxQixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUNEOztPQUVHOzs7Ozs7OztJQUVJLDBDQUFROzs7Ozs7O0lBRGYsVUFFRSxPQUFlLEVBQ2YsWUFBb0IsRUFDcEIsWUFBb0I7O1lBRWQsTUFBTSxHQUFHLFlBQVk7O1lBQ3JCLENBQUMsR0FBRyxPQUFPLEdBQUcsWUFBWTtRQUNoQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBQSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBQ0Q7OztPQUdHOzs7Ozs7SUFDSSw2Q0FBVzs7Ozs7SUFBbEI7UUFDRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDakMsQ0FBQzs7Z0JBdEVGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsb0JBQW9CO2lCQUMvQjs7OzRCQU1FLE1BQU07eUJBS04sS0FBSzsyQkFJTCxLQUFLOzJCQUlMLEtBQUs7MkJBZ0NMLFlBQVksU0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxlQUFlOztJQWtCMUQsOEJBQUM7Q0FBQSxBQXZFRCxJQXVFQztTQXBFWSx1QkFBdUI7Ozs7Ozs7SUFLbEMsNENBQXNEOzs7Ozs7SUFLdEQseUNBQTJCOzs7OztJQUkzQiwyQ0FBK0I7Ozs7O0lBSS9CLDJDQUFpQzs7Ozs7SUFJakMsMENBQXdEOzs7Ozs7OztJQU14RCxpREFBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEFmdGVyVmlld0luaXQsXG4gIE9uRGVzdHJveSxcbiAgSG9zdExpc3RlbmVyLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCB0YWtlVW50aWwsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBTY3JvbGwgfSBmcm9tICcuL3NoYXJlZC9zY3JvbGwubW9kZWwnO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJy4vc2hhcmVkL2V2ZW50cyc7XG5cbi8qKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxkaXZcbiAqICAgY2xhc3M9XCJmb29cIlxuICogICBzbkluZmluaXRlU2Nyb2xsXG4gKiAgIChzY3JvbGxFbmQpPVwib25TY3JvbGxFbmQoKVwiXG4gKiAgIFtvZmZzZXRdPVwiMTAwXCJcbiAqICAgW2RlYm91bmNlXT1cIjEyM1wiXG4gKiAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzbkluZmluaXRlU2Nyb2xsXScsXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB1c2VyIGhhcyBzY3JvbGxlZCB0b1xuICAgKiBib3R0b20gb2YgdGhlIGVsZW1lbnRcbiAgICovXG4gIEBPdXRwdXQoKSBwdWJsaWMgc2Nyb2xsRW5kID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAvKipcbiAgICogQW4gb2Zmc2V0IGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB0byB0cmlnZ2VyXG4gICAqIGBzY3JvbGxFbmRgIGV2ZW50XG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgb2Zmc2V0ID0gMDtcbiAgLyoqXG4gICAqIFNwZWNpZnkgZGVib3VuY2UgZHVyYXRpb24gaW4gbXNcbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBkZWJvdW5jZSA9IDEwMDtcbiAgLyoqXG4gICAqIElmIHRydWUgdGhlbiBgc2Nyb2xsRW5kYCBldmVudCBzaG91bGQgTk9UIGJlIGVtaXR0ZWRcbiAgICovXG4gIEBJbnB1dCgpIHB1YmxpYyBkaXNhYmxlZCA9IGZhbHNlO1xuICAvKipcbiAgICogRW1pdHMgYSBuZXcgdmFsdWUgb24gZWxlbWVudCBzY3JvbGwgZXZlbnRcbiAgICovXG4gIHB1YmxpYyBzY3JvbGwkOiBTdWJqZWN0PFNjcm9sbD4gPSBuZXcgU3ViamVjdDxTY3JvbGw+KCk7XG4gIC8qKlxuICAgKiBDb21wbGV0ZXMgb24gY29tcG9uZW50IGRlc3Ryb3kgbGlmZWN5Y2xlIGV2ZW50XG4gICAqIHVzZWQgdG8gdW5zdWJzY3JpYmUgZnJvbSBpbmZpbml0ZSBvYnNlcnZhYmxlc1xuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBuZ1Vuc3Vic2NyaWJlJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gYHNjcm9sbCRgIG9ic2VydmFibGUgYW5kIGVtaXQgYHNjcm9sbEVuZGAgZXZlbnRcbiAgICogd2hlbiBlbGVtZW50IHNjcm9sbCBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBlbGVtZW50XG4gICAqL1xuICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuc2Nyb2xsJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSxcbiAgICAgICAgZGVib3VuY2VUaW1lKHRoaXMuZGVib3VuY2UpLFxuICAgICAgICBtYXAoc2Nyb2xsID0+IHtcbiAgICAgICAgICBjb25zdCB5ID0gc2Nyb2xsLnkgKyB0aGlzLm9mZnNldDtcbiAgICAgICAgICByZXR1cm4geyB5LCBoZWlnaHQ6IHNjcm9sbC5oZWlnaHQgfTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcigoKSA9PiAhdGhpcy5kaXNhYmxlZCksXG4gICAgICAgIGZpbHRlcihzY3JvbGwgPT4gc2Nyb2xsLnkgPj0gc2Nyb2xsLmhlaWdodCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2Nyb2xsRW5kLmVtaXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGVsZW1lbnQgc2Nyb2xsIGV2ZW50IGVtaXQgbmV4dCBgc2Nyb2xsJGAgb2JzZXJ2YWJsZSB2YWx1ZVxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcihldmVudHMuZXZlbnRTY3JvbGwsIGV2ZW50cy5ldmVudFBhdGhTY3JvbGwpXG4gIHB1YmxpYyBvblNjcm9sbChcbiAgICBzY3JvbGxZOiBudW1iZXIsXG4gICAgc2Nyb2xsaGVpZ2h0OiBudW1iZXIsXG4gICAgb2Zmc2V0SGVpZ2h0OiBudW1iZXIsXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGhlaWdodCA9IHNjcm9sbGhlaWdodDtcbiAgICBjb25zdCB5ID0gc2Nyb2xsWSArIG9mZnNldEhlaWdodDtcbiAgICB0aGlzLnNjcm9sbCQubmV4dCh7IHksIGhlaWdodCB9KTtcbiAgfVxuICAvKipcbiAgICogdHJpZ2dlciBgbmdVbnN1YnNjcmliZWAgY29tcGxldGUgb25cbiAgICogY29tcG9uZW50IGRlc3Ryb3kgbGlmZWN5Y2xlIGhvb2tcbiAgICovXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLm5nVW5zdWJzY3JpYmUkLm5leHQoKTtcbiAgICB0aGlzLm5nVW5zdWJzY3JpYmUkLmNvbXBsZXRlKCk7XG4gIH1cbn1cbiJdfQ==