/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, HostListener, EventEmitter, Input, Output, } from '@angular/core';
import { Subject } from 'rxjs';
import { debounceTime, takeUntil, filter, map } from 'rxjs/operators';
import * as events from './shared/events';
/**
 * \@example
 * ```html
 * <div
 *   class="foo"
 *   snInfiniteScroll
 *   (scrollEnd)="onScrollEnd()"
 *   [offset]="100"
 *   [debounce]="123"
 *   [disabled]="disabled">
 * </div>
 * ```
 *
 */
export class InfiniteScrollDirective {
    constructor() {
        /**
         * Event that will be triggered when user has scrolled to
         * bottom of the element
         */
        this.scrollEnd = new EventEmitter();
        /**
         * An offset from the bottom of the element to trigger
         * `scrollEnd` event
         */
        this.offset = 0;
        /**
         * Specify debounce duration in ms
         */
        this.debounce = 100;
        /**
         * If true then `scrollEnd` event should NOT be emitted
         */
        this.disabled = false;
        /**
         * Emits a new value on element scroll event
         */
        this.scroll$ = new Subject();
        /**
         * Completes on component destroy lifecycle event
         * used to unsubscribe from infinite observables
         *
         */
        this.ngUnsubscribe$ = new Subject();
    }
    /**
     * Subscribe to `scroll$` observable and emit `scrollEnd` event
     * when element scroll position is at the end of the element
     * @return {?}
     */
    ngAfterViewInit() {
        this.scroll$
            .pipe(takeUntil(this.ngUnsubscribe$), debounceTime(this.debounce), map(scroll => {
            /** @type {?} */
            const y = scroll.y + this.offset;
            return { y, height: scroll.height };
        }), filter(() => !this.disabled), filter(scroll => scroll.y >= scroll.height))
            .subscribe(() => this.scrollEnd.emit());
    }
    /**
     * On element scroll event emit next `scroll$` observable value
     * @param {?} scrollY
     * @param {?} scrollheight
     * @param {?} offsetHeight
     * @return {?}
     */
    onScroll(scrollY, scrollheight, offsetHeight) {
        /** @type {?} */
        const height = scrollheight;
        /** @type {?} */
        const y = scrollY + offsetHeight;
        this.scroll$.next({ y, height });
    }
    /**
     * trigger `ngUnsubscribe` complete on
     * component destroy lifecycle hook
     * @return {?}
     */
    ngOnDestroy() {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
}
InfiniteScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[snInfiniteScroll]',
            },] }
];
InfiniteScrollDirective.propDecorators = {
    scrollEnd: [{ type: Output }],
    offset: [{ type: Input }],
    debounce: [{ type: Input }],
    disabled: [{ type: Input }],
    onScroll: [{ type: HostListener, args: [events.eventScroll, events.eventPathScroll,] }]
};
if (false) {
    /**
     * Event that will be triggered when user has scrolled to
     * bottom of the element
     * @type {?}
     */
    InfiniteScrollDirective.prototype.scrollEnd;
    /**
     * An offset from the bottom of the element to trigger
     * `scrollEnd` event
     * @type {?}
     */
    InfiniteScrollDirective.prototype.offset;
    /**
     * Specify debounce duration in ms
     * @type {?}
     */
    InfiniteScrollDirective.prototype.debounce;
    /**
     * If true then `scrollEnd` event should NOT be emitted
     * @type {?}
     */
    InfiniteScrollDirective.prototype.disabled;
    /**
     * Emits a new value on element scroll event
     * @type {?}
     */
    InfiniteScrollDirective.prototype.scroll$;
    /**
     * Completes on component destroy lifecycle event
     * used to unsubscribe from infinite observables
     *
     * @type {?}
     * @private
     */
    InfiniteScrollDirective.prototype.ngUnsubscribe$;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0aGlzaXNzb29uL2FuZ3VsYXItaW5maW5pdGUtc2Nyb2xsLyIsInNvdXJjZXMiOlsiYXBwL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUdULFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd0RSxPQUFPLEtBQUssTUFBTSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFtQjFDLE1BQU0sT0FBTyx1QkFBdUI7SUFIcEM7Ozs7O1FBUW1CLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDOzs7OztRQUt0QyxXQUFNLEdBQUcsQ0FBQyxDQUFDOzs7O1FBSVgsYUFBUSxHQUFHLEdBQUcsQ0FBQzs7OztRQUlmLGFBQVEsR0FBRyxLQUFLLENBQUM7Ozs7UUFJMUIsWUFBTyxHQUFvQixJQUFJLE9BQU8sRUFBVSxDQUFDOzs7Ozs7UUFNaEQsbUJBQWMsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO0lBd0MvQyxDQUFDOzs7Ozs7SUFuQ1EsZUFBZTtRQUNwQixJQUFJLENBQUMsT0FBTzthQUNULElBQUksQ0FDSCxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUM5QixZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUMzQixHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7O2tCQUNMLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNO1lBQ2hDLE9BQU8sRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUN0QyxDQUFDLENBQUMsRUFDRixNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQzVCLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUM1QzthQUNBLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDNUMsQ0FBQzs7Ozs7Ozs7SUFLTSxRQUFRLENBQ2IsT0FBZSxFQUNmLFlBQW9CLEVBQ3BCLFlBQW9COztjQUVkLE1BQU0sR0FBRyxZQUFZOztjQUNyQixDQUFDLEdBQUcsT0FBTyxHQUFHLFlBQVk7UUFDaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUNuQyxDQUFDOzs7Ozs7SUFLTSxXQUFXO1FBQ2hCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNqQyxDQUFDOzs7WUF0RUYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxvQkFBb0I7YUFDL0I7Ozt3QkFNRSxNQUFNO3FCQUtOLEtBQUs7dUJBSUwsS0FBSzt1QkFJTCxLQUFLO3VCQWdDTCxZQUFZLFNBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsZUFBZTs7Ozs7Ozs7SUE3Q3hELDRDQUFzRDs7Ozs7O0lBS3RELHlDQUEyQjs7Ozs7SUFJM0IsMkNBQStCOzs7OztJQUkvQiwyQ0FBaUM7Ozs7O0lBSWpDLDBDQUF3RDs7Ozs7Ozs7SUFNeEQsaURBQTZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3ksXG4gIEhvc3RMaXN0ZW5lcixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgdGFrZVVudGlsLCBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgU2Nyb2xsIH0gZnJvbSAnLi9zaGFyZWQvc2Nyb2xsLm1vZGVsJztcbmltcG9ydCAqIGFzIGV2ZW50cyBmcm9tICcuL3NoYXJlZC9ldmVudHMnO1xuXG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8ZGl2XG4gKiAgIGNsYXNzPVwiZm9vXCJcbiAqICAgc25JbmZpbml0ZVNjcm9sbFxuICogICAoc2Nyb2xsRW5kKT1cIm9uU2Nyb2xsRW5kKClcIlxuICogICBbb2Zmc2V0XT1cIjEwMFwiXG4gKiAgIFtkZWJvdW5jZV09XCIxMjNcIlxuICogICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc25JbmZpbml0ZVNjcm9sbF0nLFxufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdXNlciBoYXMgc2Nyb2xsZWQgdG9cbiAgICogYm90dG9tIG9mIHRoZSBlbGVtZW50XG4gICAqL1xuICBAT3V0cHV0KCkgcHVibGljIHNjcm9sbEVuZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgLyoqXG4gICAqIEFuIG9mZnNldCBmcm9tIHRoZSBib3R0b20gb2YgdGhlIGVsZW1lbnQgdG8gdHJpZ2dlclxuICAgKiBgc2Nyb2xsRW5kYCBldmVudFxuICAgKi9cbiAgQElucHV0KCkgcHVibGljIG9mZnNldCA9IDA7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGRlYm91bmNlIGR1cmF0aW9uIGluIG1zXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgZGVib3VuY2UgPSAxMDA7XG4gIC8qKlxuICAgKiBJZiB0cnVlIHRoZW4gYHNjcm9sbEVuZGAgZXZlbnQgc2hvdWxkIE5PVCBiZSBlbWl0dGVkXG4gICAqL1xuICBASW5wdXQoKSBwdWJsaWMgZGlzYWJsZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEVtaXRzIGEgbmV3IHZhbHVlIG9uIGVsZW1lbnQgc2Nyb2xsIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgc2Nyb2xsJDogU3ViamVjdDxTY3JvbGw+ID0gbmV3IFN1YmplY3Q8U2Nyb2xsPigpO1xuICAvKipcbiAgICogQ29tcGxldGVzIG9uIGNvbXBvbmVudCBkZXN0cm95IGxpZmVjeWNsZSBldmVudFxuICAgKiB1c2VkIHRvIHVuc3Vic2NyaWJlIGZyb20gaW5maW5pdGUgb2JzZXJ2YWJsZXNcbiAgICpcbiAgICovXG4gIHByaXZhdGUgbmdVbnN1YnNjcmliZSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGBzY3JvbGwkYCBvYnNlcnZhYmxlIGFuZCBlbWl0IGBzY3JvbGxFbmRgIGV2ZW50XG4gICAqIHdoZW4gZWxlbWVudCBzY3JvbGwgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgZWxlbWVudFxuICAgKi9cbiAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnNjcm9sbCRcbiAgICAgIC5waXBlKFxuICAgICAgICB0YWtlVW50aWwodGhpcy5uZ1Vuc3Vic2NyaWJlJCksXG4gICAgICAgIGRlYm91bmNlVGltZSh0aGlzLmRlYm91bmNlKSxcbiAgICAgICAgbWFwKHNjcm9sbCA9PiB7XG4gICAgICAgICAgY29uc3QgeSA9IHNjcm9sbC55ICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIHsgeSwgaGVpZ2h0OiBzY3JvbGwuaGVpZ2h0IH07XG4gICAgICAgIH0pLFxuICAgICAgICBmaWx0ZXIoKCkgPT4gIXRoaXMuZGlzYWJsZWQpLFxuICAgICAgICBmaWx0ZXIoc2Nyb2xsID0+IHNjcm9sbC55ID49IHNjcm9sbC5oZWlnaHQpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNjcm9sbEVuZC5lbWl0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBPbiBlbGVtZW50IHNjcm9sbCBldmVudCBlbWl0IG5leHQgYHNjcm9sbCRgIG9ic2VydmFibGUgdmFsdWVcbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoZXZlbnRzLmV2ZW50U2Nyb2xsLCBldmVudHMuZXZlbnRQYXRoU2Nyb2xsKVxuICBwdWJsaWMgb25TY3JvbGwoXG4gICAgc2Nyb2xsWTogbnVtYmVyLFxuICAgIHNjcm9sbGhlaWdodDogbnVtYmVyLFxuICAgIG9mZnNldEhlaWdodDogbnVtYmVyLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBoZWlnaHQgPSBzY3JvbGxoZWlnaHQ7XG4gICAgY29uc3QgeSA9IHNjcm9sbFkgKyBvZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5zY3JvbGwkLm5leHQoeyB5LCBoZWlnaHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHRyaWdnZXIgYG5nVW5zdWJzY3JpYmVgIGNvbXBsZXRlIG9uXG4gICAqIGNvbXBvbmVudCBkZXN0cm95IGxpZmVjeWNsZSBob29rXG4gICAqL1xuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5uZXh0KCk7XG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5jb21wbGV0ZSgpO1xuICB9XG59XG4iXX0=